# =========================================================
#  ESP32 Voice Assistant (HackMyHome) - Final Stable Core
#  - Wake word + Continuous conversation
#  - Centralized LED control (control_leds)
# - Added Hey Aura + Hey Elsa (thank to https://github.com/TaterTotterson/microWakeWords)
# =========================================================

substitutions:
  # -------- Identity --------
  hostname: "voice-assist-01"
  friendly: "HA Voice Assist O1"

  # -------- WiFi --------
  ip: "192.168.31.21"
  gateway: "192.168.31.1"
  subnet: "255.255.255.0"
  dns: "192.168.1.1"

  # -------- I2S pins --------
  i2s_lrclk_pin: "GPIO11"
  i2s_bclk_pin: "GPIO10"
  i2s_din_pin:  "GPIO15"
  i2s_dout_pin: "GPIO9"

  # -------- Audio tuning --------
  ampli_sd_pin: "GPIO46"
  sample_rate_hz: "44100"
  mic_gain_factor: "4"
  noise_sup: "0"

  # -------- LED ring --------
  led_pin: "GPIO13"
  led_count: "64"
  led_rotate_ms: "100ms"
  led_standby_ms: "50ms"

  # -------- Label Tasti--------
  pin_t1: "GPIO4"
  pin_t2: "GPIO5"
  pin_t3: "GPIO6"
  pin_t4: "GPIO7"
  pin_t5: "GPIO8"
  tasto1: "05 -"
  tasto2: "03 LED"
  tasto3: "04 +"
  tasto4: "02 Memoria"
  tasto5: "01 Power"

  # Standby (two dots)
  standby_speed_ms: "90"
  standby_gap: "3"
  standby_r1: "120"
  standby_g1: "0"
  standby_b1: "120"
  standby_r2: "50"
  standby_g2: "0"
  standby_b2: "50"

  # Listening dot + background
  listen_fg_r: "0"
  listen_fg_g: "200"
  listen_fg_b: "0"
  listen_bg_r: "0"
  listen_bg_g: "0"
  listen_bg_b: "60"

  # Thinking
  think_fg_r: "200"
  think_fg_g: "0"
  think_fg_b: "20"
  think_bg_r: "0"
  think_bg_g: "0"
  think_bg_b: "60"

  # Speaking
  speak_fg_r: "255"
  speak_fg_g: "200"
  speak_fg_b: "0"
  speak_bg_r: "120"
  speak_bg_g: "0"
  speak_bg_b: "0"

  # Error
  err_fg_r: "255"
  err_fg_g: "0"
  err_fg_b: "0"
  err_bg_r: "10"
  err_bg_g: "0"
  err_bg_b: "0"

  # -------- Voice Assistant Phases --------
  voice_assist_idle_phase_id: "1"
  voice_assist_listening_phase_id: "2"
  voice_assist_thinking_phase_id: "3"
  voice_assist_replying_phase_id: "4"
  voice_assist_not_ready_phase_id: "10"
  voice_assist_error_phase_id: "11"
  voice_assist_muted_phase_id: "12"
  voice_assist_timer_finished_phase_id: "20"

globals:
  - id: init_in_progress
    type: bool
    restore_value: false
    initial_value: "false"
  - id: boot_sound
    type: bool
    restore_value: false
    initial_value: "false"
  - id: voice_assistant_phase
    type: int
    restore_value: false
    initial_value: ${voice_assist_not_ready_phase_id}

  - id: fg_r
    type: int
    restore_value: false
    initial_value: "0"
  - id: fg_g
    type: int
    restore_value: false
    initial_value: "0"
  - id: fg_b
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_r
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_g
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_b
    type: int
    restore_value: false
    initial_value: "0"

  - id: ts_va_listening_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_vad_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_stt_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_tts_start_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_reply_done_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: question
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: answer
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: idle_effect_index
    type: int
    restore_value: yes
    initial_value: '0'
  - id: user_brightness
    type: float
    initial_value: '0.75'
  - id: user_brightness_dir_up
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: device_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'

esphome:
  name: ${hostname}
  friendly_name: ${friendly}
  project:
    name: HackMyHome.VoiceAssist
    version: '2.3.0'
  on_boot:
    priority: 600
    then:
      - logger.log:
          level: INFO
          format: "=== BOOT START"
      - logger.log:
          level: INFO
          format: "=== BOOT END"
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: id(init_in_progress) = false;
  on_shutdown:
    then:
      - logger.log:
          level: INFO
          format: "SHUTDOWN: stop audio and led ring"
      - media_player.stop:
          id: speaker_media_player
      - micro_wake_word.stop:
      - voice_assistant.stop:

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"

logger:
  level: INFO

psram:
  mode: octal
  speed: 80MHz

wifi:
  ssid: "inserisci_ssid"
  password: "inserisci_pwd"
  fast_connect: true
  manual_ip:
    static_ip: ${ip}
    gateway: ${gateway}
    subnet: ${subnet}
    dns1: ${dns}
    dns2: 8.8.8.8
  ap:
    ssid: "${friendly} Fallback"
    password: "inesrisci_pwd"
  on_connect:
    then:
      - logger.log:
          level: INFO
          format: "WiFi: connected"
  on_disconnect:
    then:
      - logger.log:
          level: INFO
          format: "WiFi: disconnected"

api:
  encryption:
    key: "CiNgQqOfbti7EO2MJWx+lGptEgBe9O2YHfdgdts26U4="
  on_client_connected: 
    then:
      - logger.log:
          level: INFO
          format: "=== API CONNECTED"
      - if:
          condition:
            not:
              lambda: return id(boot_sound);
          then:
            - logger.log:
                level: INFO
                format: "=== API CONNECTED - Boot sound"
            - micro_wake_word.stop
            - voice_assistant.stop
      - if:
          condition:
            not:
              - micro_wake_word.is_running:
          then:
            - micro_wake_word.start:
            - delay: 200ms
            - logger.log:
                level: INFO
                format: "==== API CONNECTED - WakeWord: Start"
      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
      - script.execute: control_leds      

ota:
  - platform: esphome
    password: "777947954e176a894bb4402f586e789c"

captive_portal:

button:
  - platform: restart
    id: btn_reboot
    name: "Reboot ESP"
    entity_category: diagnostic
    icon: mdi:restart

  - platform: safe_mode
    id: btn_safe_boot
    name: "Safe Boot (Modalità provvisoria)"
    entity_category: diagnostic
    icon: mdi:shield-alert


i2s_audio:
  - id: i2s_output
    i2s_bclk_pin:
      number: ${i2s_bclk_pin}
    i2s_lrclk_pin:
      number: ${i2s_lrclk_pin}

microphone:
  - platform: i2s_audio
    id: box_mic
    i2s_audio_id: i2s_output
    i2s_din_pin: ${i2s_din_pin}
    adc_type: external
    channel: left

speaker:
  - platform: i2s_audio
    id: box_speaker
    i2s_audio_id: i2s_output
    i2s_dout_pin: ${i2s_dout_pin}
    dac_type: external
    sample_rate: ${sample_rate_hz}
    channel: stereo
    buffer_duration: 100ms

media_player:
  - platform: speaker
    name: "${friendly} Speaker"
    id: speaker_media_player
    volume_increment: 0.1
    task_stack_in_psram: true
    announcement_pipeline:
      speaker: box_speaker
      format: FLAC
      sample_rate: 48000
      num_channels: 1
    on_announcement:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: ANNOUNCEMENT ===="
      # Stop the wake word (mWW or VA) if the mic is capturing
      - if:
          condition:
            - microphone.is_capturing:
          then:
            - script.execute: stop_wake_word
            # Ensure VA stops before moving on
            - if:
                condition:
                  - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
                then:
                  - wait_until:
                      - not:
                          voice_assistant.is_running:
      # Since VA isn't running, this is user-intiated media playback. Draw the mute display
      - if:
          condition:
            not:
              voice_assistant.is_running:
          then:
            - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
      - script.execute: control_leds

    on_idle:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: IDLE ===="
      - if:
          condition:
            not:
              - voice_assistant.is_running:
          then:
            - logger.log:
                level: INFO
                format: "==== MediaPlayer: IDLE - RESTART WAKE WORD ===="
            - script.execute: start_wake_word
      - script.execute: control_leds

    on_play:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: PLAY ===="
      - script.execute: control_leds

micro_wake_word:
  id: mww
  stop_after_detection: false
  microphone:
    microphone: box_mic
    channels: 0
    gain_factor: ${mic_gain_factor}

  models:
    - model: hey_jarvis
      id: hey_jarvis
    - model: https://raw.githubusercontent.com/TaterTotterson/microWakeWords/refs/heads/main/microWakeWords/hey_aowurrah.json
      id: hey_aowurrah
    - model: https://raw.githubusercontent.com/TaterTotterson/microWakeWords/refs/heads/main/microWakeWords/hey_aura.json
      id: hey_aura

  on_wake_word_detected:
    - lambda: |-
        ESP_LOGI("micro_wake_word", "==== WAKEWORD DETECTED (%s) ====", wake_word.c_str());
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: START"  
    - voice_assistant.start_continuous:   
    - script.execute: control_leds

voice_assistant:
  id: va
  microphone: box_mic
  media_player: speaker_media_player
  micro_wake_word: mww
  noise_suppression_level: ${noise_sup}
  auto_gain: 31dBFS
  volume_multiplier: 3.0
  on_listening:
    - lambda: id(ts_va_listening_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: LISTENING (t=%u ms)"
        args: ['(unsigned) id(ts_va_listening_ms)']
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
    - text_sensor.template.publish:
        id: text_request
        state: "..."
    - text_sensor.template.publish:
        id: text_response
        state: "..."
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(ts_va_vad_end_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: STT VAD END (t=%u ms)"
        args: ['(unsigned) id(ts_va_vad_end_ms)']
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_stt_end:
    - lambda: |-
        id(question) = x.c_str();
        id(ts_va_stt_end_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: STT END (t=%u ms)"
        args: ['(unsigned) id(ts_va_stt_end_ms)']
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant - Question: %s"
        args: ['id(question).c_str()']
    - text_sensor.template.publish:
        id: text_request
        state: !lambda return x;

    - if:
        condition:
          lambda: |-
            std::string t = id(question).c_str();
            for (auto &c : t) c = tolower((unsigned char)c);
            return (t.find("silenziosa") != std::string::npos);
        then:
          - delay: 500ms
          - voice_assistant.stop
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: Voice Assistant: Stop"
          - micro_wake_word.start:
          - delay: 200ms
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: WakeWord: Start"
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_tts_start:
    - lambda: |-
        id(answer) = x.c_str();
        id(ts_va_tts_start_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TTS START (t=%u ms)"
        args: ['(unsigned) id(ts_va_tts_start_ms)']
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant - Answer %s"
        args: ['id(answer).c_str()']
    - text_sensor.template.publish:
        id: text_response
        state: !lambda return x;
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    # "modalità silenziosa" -> esci
    - if:
        condition:
          lambda: |-
            std::string t = x;
            for (auto &c : t) c = tolower((unsigned char)c);
            return (t.find("modalità silenziosa") != std::string::npos);
        then:
          - delay: 500ms
          - voice_assistant.stop
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: Voice Assistant: Stop"
          - micro_wake_word.start:
          - delay: 200ms
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: WakeWord: Start"
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
#    - logger.log:
#        level: INFO
#        format: "==== Invio risposta ad Alexa"
#    - homeassistant.service:
#        service: notify.alexa_media
#        data:
#          target: media_player.echo_dot_cameretta
#          message: !lambda 'return x;'

  on_end:
    # Wait a short amount of time to see if an announcement starts
    - lambda: id(ts_va_reply_done_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: END (t=%u ms)"
        args: ['(unsigned) id(ts_va_reply_done_ms)']
    - wait_until:
        condition:
          - media_player.is_announcing:
        timeout: 0.5s
        
    # Announcement is finished and the I2S bus is free
    - wait_until:
        - and:
            - not:
                media_player.is_announcing:
            - not:
                speaker.is_playing:
    - lambda: id(ts_va_reply_done_ms) = millis();

    # Restart only mWW if enabled; streaming wake words automatically restart
    - if:
        condition:
          - lambda: return id(wake_word_engine_location).state == "On device";
        then:
          - lambda: id(va).set_use_wake_word(false);
          - if:
              condition:
                not:
                  - micro_wake_word.is_running:
              then:
                - micro_wake_word.start:
                - delay: 200ms
                - logger.log:
                    level: INFO
                    format: "==== WakeWord: Start"

    # Clear text sensors
    - text_sensor.template.publish:
        id: text_request
        state: ""
    - text_sensor.template.publish:
        id: text_response
        state: ""
    - script.execute: control_leds
    - lambda: id(ts_va_end_ms) = millis();
    - script.execute: va_timing_report
  on_error:
    - logger.log:
        level: ERROR
        format: "==== VoiceAssistant: ERROR: %s - %s"
        args: [ 'code.c_str()', 'message.c_str()' ]
    # Se è solo "no text", non andare in errore
    - if:
        condition:
          lambda: return code == "stt-no-text-recognized";
        then:
          - logger.log:
              level: INFO
              format: "==== VoiceAssistant: no-text -> Stop&Start"
          - if:
              condition:
                - micro_wake_word.is_running:
              then:
                - micro_wake_word.stop
                - delay: 500ms
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: no-text -> Stop WakeWord"
          - if:
              condition:
                - voice_assistant.is_running:
              then:
                - voice_assistant.stop
                - delay: 500ms
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: no-text -> Stop Voice Assistant"
          - logger.log:
              level: INFO
              format: "==== VoiceAssistant: no-text -> Start"
          - voice_assistant.start_continuous
          - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
          - script.execute: control_leds
        else:
          # Se è "intent-failed - Unexpected error during intent recognition", restart
          - if:
              condition:
                lambda: return code == "intent-failed";
              then:
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: intent error -> Stop&Start"
                - if:
                    condition:
                      - micro_wake_word.is_running:
                    then:
                      - micro_wake_word.stop
                      - delay: 500ms
                      - logger.log:
                          level: INFO
                          format: "==== VoiceAssistant: intent-error -> Stop WakeWord"
                - if:
                    condition:
                      - voice_assistant.is_running:
                    then:
                      - voice_assistant.stop
                      - delay: 500ms
                      - logger.log:
                          level: INFO
                          format: "==== VoiceAssistant: intent-error -> Stop Voice Assistant"
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: inten-error -> Start"
                - voice_assistant.start_continuous
                - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
                - script.execute: control_leds
        # qui lasci la tua gestione "vera" degli errori
    - if:
        condition:
          lambda: return !id(init_in_progress);
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};

  on_client_connected:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: CLIENT CONNECTED ===="
    - lambda: id(init_in_progress) = false;
    - script.execute: start_wake_word
    - script.execute: control_leds
  on_client_disconnected:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: DISCONNECTED ===="
    - script.execute: stop_wake_word
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_timer_started:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER STARTED ===="
    - script.execute: control_leds
  on_timer_cancelled:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER CANCELLED ===="
    - script.execute: control_leds
  on_timer_updated:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER UPDATED ===="
    - script.execute: control_leds
  on_timer_tick:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER TICK ===="
    - script.execute: control_leds
  on_timer_finished:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER FINISHED ===="
    - switch.turn_on: timer_ringing
    - wait_until:
        media_player.is_announcing:
    - lambda: id(voice_assistant_phase) = ${voice_assist_timer_finished_phase_id};
    - script.execute: control_leds

script:
  - id: power_toggle
    mode: restart
    then:
      - lambda: id(device_enabled) = !id(device_enabled);
      - script.execute: power_apply

  - id: power_apply
    mode: restart
    then:
      - if:
          condition:
            lambda: return id(device_enabled);
          then:
            - logger.log: "POWER -> ON (standby + wake word)"
            - micro_wake_word.start:
            # Avvia VA solo quando HA è connesso (evita errori a boot)
            - if:
                condition:
                  and:
                    - wifi.connected:
                    - api.connected:
                then:
                  - voice_assistant.start_continuous:
            # Ripristina ultimo effetto idle (quello che cicli con +/-)
            - script.execute: apply_idle_effect
            - script.execute: control_leds

          else:
            - logger.log: "POWER -> OFF (stop all)"
            - voice_assistant.stop:
            - micro_wake_word.stop:
            - media_player.stop: speaker_media_player
            - light.turn_off: led_ring

  - id: va_timing_report
    mode: restart
    then:
      - lambda: |-
          auto ms_to_s = [](uint32_t ms) -> float { return ((float) ms) / 1000.0f; };

          const uint32_t t_listen = id(ts_va_listening_ms);
          const uint32_t t_vad    = id(ts_va_vad_end_ms);
          const uint32_t t_stt    = id(ts_va_stt_end_ms);       // "ha capito cosa chiedo"
          const uint32_t t_tts    = id(ts_va_tts_start_ms);
          const uint32_t t_done   = id(ts_va_reply_done_ms);    // fine parlato reale
          const uint32_t t_end    = id(ts_va_end_ms);           // fine on_end (cleanup)

          // Report principale: STT_END -> SPEECH_END
          if (t_stt == 0 || t_tts == 0 || t_done == 0 || t_done <= t_stt || t_tts < t_stt) {
            ESP_LOGI("va_timing", "VA Timing: incomplete (stt=%u tts=%u done=%u)", t_stt, t_tts, t_done);
            return;
          }

          const uint32_t total_ms = t_done - t_stt;
          const uint32_t think_ms = t_tts - t_stt;
          const uint32_t speak_ms = t_done - t_tts;

          auto pct = [&](uint32_t part_ms) -> float {
            return (total_ms > 0) ? (100.0f * ((float) part_ms) / (float) total_ms) : 0.0f;
          };

          ESP_LOGI("va_timing", "=== VA Timing Report (STT_END -> SPEECH_END) ===");
          ESP_LOGI("va_timing", "Total: %.2fs", ms_to_s(total_ms));
          ESP_LOGI("va_timing", "Thinking (STT_END->TTS_START): %.2fs (%.1f%%)", ms_to_s(think_ms), pct(think_ms));
          ESP_LOGI("va_timing", "Speaking (TTS_START->SPEECH_END): %.2fs (%.1f%%)", ms_to_s(speak_ms), pct(speak_ms));

          // Extra (non inclusi nel totale richiesto, ma utili per debug)
          if (t_listen && t_vad && t_vad > t_listen) {
            ESP_LOGI("va_timing", "Pre: Listening->VAD_END: %.2fs", ms_to_s(t_vad - t_listen));
          }
          if (t_vad && t_stt && t_stt > t_vad) {
            ESP_LOGI("va_timing", "Pre: VAD_END->STT_END: %.2fs", ms_to_s(t_stt - t_vad));
          }
          if (t_end && t_end > t_done) {
            ESP_LOGI("va_timing", "Post: SPEECH_END->END(cleanup): %.2fs", ms_to_s(t_end - t_done));
          }

          ESP_LOGI("va_timing", "==============================================");

  # Starts either mWW or the streaming wake word, depending on the configured location
  - id: start_wake_word
    then:
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - if:
                condition:
                  not:
                    - micro_wake_word.is_running:
                then:
                  - micro_wake_word.start:
                  - delay: 200ms
                  - logger.log:
                      level: INFO
                      format: "==== WakeWord: Start"
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous:
  # Stops either mWW or the streaming wake word, depending on the configured location
  - id: stop_wake_word
    then:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - micro_wake_word.stop:
  # Set the voice assistant phase to idle or muted, depending on if the software mute switch is activated

  - id: control_leds
    mode: restart
    then:
      # Se siamo ancora in init → boot scan
      - if:
          condition:
            lambda: return !id(device_enabled);
          then:
            - light.turn_off: led_ring
          else:
            # ... tutto il tuo control_leds attuale qui sotto ...
            - if:
                condition:
                  lambda: return id(init_in_progress);
                then:
                  - lambda: |-
                      auto call = id(led_ring).turn_on();
                      call.set_brightness(0.55f);
                      call.set_effect("Fast Pulse");
                      call.perform();
                else:
                  # Se manca WiFi o API → standby
                  - if:
                      condition:
                        and:
                          - wifi.connected:
                          - api.connected:
                      then:
                        - lambda: |-
                            // helper: applica un effetto + brightness (+ opzionale rgb)
                            auto apply_effect = [&](const char *effect, float br, bool set_rgb,
                                                    float r, float g, float b) {
                              auto call = id(led_ring).turn_on();
                              float eff_br = id(user_brightness);
                              call.set_brightness(eff_br);
                              call.set_effect(effect);
                              if (set_rgb) call.set_rgb(r, g, b);
                              call.perform();
                            };

                            const int phase = id(voice_assistant_phase);

                            switch (phase) {

                              case ${voice_assist_listening_phase_id}: {
                                id(fg_r) = atoi("${listen_fg_r}");
                                id(fg_g) = atoi("${listen_fg_g}");
                                id(fg_b) = atoi("${listen_fg_b}");
                                id(bg_r) = atoi("${listen_bg_r}");
                                id(bg_g) = atoi("${listen_bg_g}");
                                id(bg_b) = atoi("${listen_bg_b}");
                                apply_effect("VA Ascolto - Radar", 0.65f, false, 0, 0, 0);
                                break;
                              }

                              case ${voice_assist_thinking_phase_id}: {
                                id(fg_r) = atoi("${think_fg_r}");
                                id(fg_g) = atoi("${think_fg_g}");
                                id(fg_b) = atoi("${think_fg_b}");
                                id(bg_r) = atoi("${think_bg_r}");
                                id(bg_g) = atoi("${think_bg_g}");
                                id(bg_b) = atoi("${think_bg_b}");
                                apply_effect("VA Penso - Neuroni", 0.70f, false, 0, 0, 0);
                                break;
                              }

                              case ${voice_assist_replying_phase_id}: {
                                id(fg_r) = atoi("${speak_fg_r}");
                                id(fg_g) = atoi("${speak_fg_g}");
                                id(fg_b) = atoi("${speak_fg_b}");
                                id(bg_r) = atoi("${speak_bg_r}");
                                id(bg_g) = atoi("${speak_bg_g}");
                                id(bg_b) = atoi("${speak_bg_b}");
                                apply_effect("VA Parlo - Voice Bars", 0.70f, false, 0, 0, 0);
                                break;
                              }

                              case ${voice_assist_error_phase_id}: {
                                apply_effect("Error Blink", 0.90f, false, 0, 0, 0);
                                break;
                              }

                              case ${voice_assist_muted_phase_id}: {
                                const float r = atoi("${speak_bg_r}") / 255.0f;
                                const float g = atoi("${speak_bg_g}") / 255.0f;
                                const float b = atoi("${speak_bg_b}") / 255.0f;
                                apply_effect("Slow Pulse", 0.35f, true, r, g, b);
                                break;
                              }

                              case ${voice_assist_not_ready_phase_id}: {
                                apply_effect("Plasma", 0.35f, false, 0, 0, 0);
                                break;
                              }

                              case ${voice_assist_timer_finished_phase_id}: {
                                const float r = atoi("${speak_fg_r}") / 255.0f;
                                const float g = atoi("${speak_fg_g}") / 255.0f;
                                const float b = atoi("${speak_fg_b}") / 255.0f;
                                apply_effect("Fast Pulse", 0.95f, true, r, g, b);
                                break;
                              }

                              default: {
                                apply_effect("Plasma", 0.35f, false, 0, 0, 0);
                                break;
                              }
                            }
                      else:
                        - lambda: |-
                            auto call = id(led_ring).turn_on();
                            call.set_brightness(0.35f);
                            call.set_effect("Plasma");
                            call.perform();

  - id: apply_idle_effect
    mode: restart
    then:
      - lambda: |-
          // elenco effetti "idle" (devono esistere nella light della matrice)
          const char* fx[] = {
            "Slow Pulse",
            "VA Standby",
            "Fiamma",
            "Plasma",
            "VA Penso - Neuroni"
          };
          const int N = sizeof(fx)/sizeof(fx[0]);

          int i = id(idle_effect_index);
          if (i < 0) i = 0;
          if (i >= N) i = N-1;
          id(idle_effect_index) = i;

          auto call = id(led_ring).turn_on();   // <-- se la matrice ha un altro id, cambia qui
          call.set_brightness(0.35f);
          call.set_effect(fx[i]);
          call.perform();

  - id: cycle_idle_effect
    mode: restart
    parameters:
      dir: int
    then:
      - lambda: |-
          const int N = 5; // deve combaciare con quanti effetti hai sopra
          int i = id(idle_effect_index) + dir;
          if (i < 0) i = N - 1;
          if (i >= N) i = 0;
          id(idle_effect_index) = i;
      - script.execute: apply_idle_effect

switch:
  - platform: gpio
    name: Silenzioso
    id: amp_on
    pin: ${ampli_sd_pin}
    restore_mode: ALWAYS_OFF
    inverted: yes

  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      # Turn off the repeat mode and disable the pause between playlist items
      - lambda: |-
              id(speaker_media_player)
                ->make_call()
                .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
                .set_announcement(true)
                .perform();
              id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);
      # Stop playing the alarm
      - media_player.stop:
          announcement: true
    on_turn_on:
      # Turn on the repeat mode and pause for 1000 ms between playlist items/repeats
      - lambda: |-
            id(speaker_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 1000);
      - delay: 15min
      - switch.turn_off: timer_ringing

select:
  - platform: template
    entity_category: config
    name: Wake word engine location
    id: wake_word_engine_location
    icon: "mdi:account-voice"
    optimistic: true
    restore_value: true
    options:
      - In Home Assistant
      - On device
    initial_option: On device
    on_value:
      - if:
          condition:
            lambda: return !id(init_in_progress);
          then:
            - wait_until:
                lambda: return id(voice_assistant_phase) == ${voice_assist_muted_phase_id} || id(voice_assistant_phase) == ${voice_assist_idle_phase_id};
            - if:
                condition:
                  lambda: return x == "In Home Assistant";
                then:
                  - micro_wake_word.stop
                  - delay: 500ms
            - if:
                condition:
                  lambda: return x == "On device";
                then:
                  - lambda: id(va).set_use_wake_word(false);
                  - voice_assistant.stop
                  - delay: 500ms

sensor:
  # Sensors with general information.
  # Uptime sensor.
  - platform: uptime
    name: "Attivo da"

  # WiFi Signal sensor.
  - platform: wifi_signal
    name: "Segnale WiFi"
    update_interval: 60s
    id: wifi_level
        
# Sync time with Home Assistant.
time:
  - platform: homeassistant
    id: homeassistant_time

text_sensor:
  - id: text_request
    platform: template
    on_value:
      lambda: |-
        if(id(text_request).state.length()>32) {
          std::string name = id(text_request).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_request).state = (truncated+"...").c_str();
        }

  - id: text_response
    platform: template
    on_value:
      lambda: |-
        if(id(text_response).state.length()>32) {
          std::string name = id(text_response).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_response).state = (truncated+"...").c_str();
        }

binary_sensor:
  - platform: gpio
    id: tasto_1
    pin:
      number: ${pin_t1}
      mode: INPUT_PULLUP
      inverted: true
    name: ${tasto1}
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto1}: PREMUTO ===="
        - if:
            condition:
              or:
                - media_player.is_playing: speaker_media_player
                - media_player.is_announcing: speaker_media_player
            then:
              - media_player.volume_down: speaker_media_player
              - logger.log: "==== ${tasto1} -> Volume DOWN"
            else:
              - if:
                  condition:
                    lambda: |-
                      const int p = id(voice_assistant_phase);
                      return (p != ${voice_assist_listening_phase_id})
                          && (p != ${voice_assist_thinking_phase_id})
                          && (p != ${voice_assist_replying_phase_id});
                  then:
                    - script.execute:
                        id: cycle_idle_effect
                        dir: -1
                    - logger.log: "==== ${tasto1} -> Next effect"
                  else:
                    - logger.log: "==== ${tasto1} -> VA attivo, ignoro"
    on_release: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto1}: RILASCIATO ===="
        
  - platform: gpio
    id: tasto_2
    pin:
      number: ${pin_t2}
      mode: INPUT_PULLUP
      inverted: true
    name: ${tasto2}
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto2}: PREMUTO ===="

        - lambda: |-
            const float MINB = 0.08f;
            const float MAXB = 1.00f;
            const float STEP = 0.10f;

            float b = id(user_brightness);
            if (id(user_brightness_dir_up)) b += STEP;
            else                            b -= STEP;

            if (b >= MAXB) { b = MAXB; id(user_brightness_dir_up) = false; }
            if (b <= MINB) { b = MINB; id(user_brightness_dir_up) = true;  }

            id(user_brightness) = b;

            auto call = id(led_ring).turn_on();
            call.set_brightness(b);   // mantiene l’effetto corrente
            call.perform();

            ESP_LOGI("btn", "==== ${tasto2}: Luminosita' = %.2f", b);

    on_release: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto2}: RILASCIATO ===="

  - platform: gpio
    id: tasto_3
    pin:
      number: ${pin_t3}
      mode: INPUT_PULLUP
      inverted: true
    name: ${tasto3}
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto3}: PREMUTO ===="
        - if:
            condition:
              or:
                - media_player.is_playing: speaker_media_player
                - media_player.is_announcing: speaker_media_player
            then:
              - media_player.volume_up: speaker_media_player
              - logger.log: "==== ${tasto3} -> Volume UP"
            else:
              - if:
                  condition:
                    lambda: |-
                      const int p = id(voice_assistant_phase);
                      return (p != ${voice_assist_listening_phase_id})
                          && (p != ${voice_assist_thinking_phase_id})
                          && (p != ${voice_assist_replying_phase_id});
                  then:
                    - script.execute:
                        id: cycle_idle_effect
                        dir: 1
                    - logger.log: "==== ${tasto3} -> Next effect"
                  else:
                    - logger.log: "==== ${tasto3} -> VA attivo, ignoro"
    on_release: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto3}: RILASCIATO ===="

  - platform: gpio
    id: tasto_4
    pin:
      number: ${pin_t4}
      mode: INPUT_PULLUP
      inverted: true
    name: ${tasto4}
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto4}: PREMUTO ===="
    on_release: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto4}: RILASCIATO ===="

  - platform: gpio
    id: tasto_5
    pin:
      number: ${pin_t5}
      mode: INPUT_PULLUP
      inverted: true
    name: ${tasto5}
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms
    on_press: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto5}: PREMUTO ===="
        - script.execute: power_toggle

    on_release: 
      then:
        - logger.log:
            level: INFO
            format: "==== ${tasto5}: RILASCIATO ===="

light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    rgb_order: GRB
    id: led_ring
    name: "LED Ring"
    pin: ${led_pin}
    num_leds: ${led_count}
    restore_mode: ALWAYS_OFF
    default_transition_length: 0s
    effects:

      - addressable_lambda:
          name: "Slow Pulse"
          update_interval: 40ms
          lambda: |-
            // ====== TUNING ======
            const float SPEED_LEDS_PER_SEC = 7.0f;          // velocità rotazione
            const float TAIL_LEDS          = 2*it.size()/3; // coda (in led)
            const float TRANSITION_SEC     = 2.2f;          // durata crossfade colore
            const float SAT                = 0.95f;         // saturazione colori
            const float VAL                = 1.00f;         // luminosità colori
            // =====================

            auto smoothstep = [](float x) -> float {
              x = (x < 0.0f) ? 0.0f : (x > 1.0f ? 1.0f : x);
              return x * x * (3.0f - 2.0f * x);
            };

            auto hsv_to_rgb = [](float h, float s, float v) -> Color {
              h = fmodf(h, 360.0f);
              if (h < 0) h += 360.0f;

              float c = v * s;
              float x = c * (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
              float m = v - c;

              float rp=0, gp=0, bp=0;
              if      (h < 60)  { rp=c; gp=x; bp=0; }
              else if (h < 120) { rp=x; gp=c; bp=0; }
              else if (h < 180) { rp=0; gp=c; bp=x; }
              else if (h < 240) { rp=0; gp=x; bp=c; }
              else if (h < 300) { rp=x; gp=0; bp=c; }
              else              { rp=c; gp=0; bp=x; }

              uint8_t r = (uint8_t) ((rp + m) * 255.0f);
              uint8_t g = (uint8_t) ((gp + m) * 255.0f);
              uint8_t b = (uint8_t) ((bp + m) * 255.0f);
              return Color(r, g, b);
            };

            auto lerp_color = [](const Color &a, const Color &b, float t) -> Color {
              t = (t < 0.0f) ? 0.0f : (t > 1.0f ? 1.0f : t);
              uint8_t r = (uint8_t) (a.red   + (b.red   - a.red)   * t);
              uint8_t g = (uint8_t) (a.green + (b.green - a.green) * t);
              uint8_t b2= (uint8_t) (a.blue  + (b.blue  - a.blue)  * t);
              return Color(r, g, b2);
            };

            auto random_nice_color = [&]() -> Color {
              float hue = (float)(random_uint32() % 360);
              return hsv_to_rgb(hue, SAT, VAL);
            };

            static bool init = false;
            static uint32_t last_ms = 0;

            static float pos = 0.0f;            // posizione cometa
            static float tcol = 0.0f;           // 0..1 progress transizione colore
            static Color c_from(255, 0, 0);
            static Color c_to(0, 255, 255);

            uint32_t now = millis();
            float dt = 0.0f;
            if (last_ms != 0) dt = (now - last_ms) / 1000.0f;
            last_ms = now;

            if (!init) {
              c_from = random_nice_color();
              c_to   = random_nice_color();
              init = true;
            }

            // Avanza posizione
            if (dt > 0.0f) {
              pos += SPEED_LEDS_PER_SEC * dt;
              float n = (float) it.size();
              pos = fmodf(pos, n);
              if (pos < 0) pos += n;
            }

            // Transizione colore
            if (dt > 0.0f) tcol += dt / TRANSITION_SEC;
            if (tcol >= 1.0f) {
              tcol = 0.0f;
              c_from = c_to;
              c_to = random_nice_color();
            }

            float e = smoothstep(tcol);
            Color c = lerp_color(c_from, c_to, e);

            // Disegna cometa con coda (wrap su anello)
            int n = it.size();
            for (int i = 0; i < n; i++) {
              float d = fabsf((float)i - pos);
              d = fminf(d, (float)n - d);   // distanza su anello (wrap)
              float b = 1.0f - (d / TAIL_LEDS);
              if (b < 0.0f) b = 0.0f;
              b = b * b; // morbida (easing della coda)

              it[i] = Color(
                (uint8_t)(c.red   * b),
                (uint8_t)(c.green * b),
                (uint8_t)(c.blue  * b)
              );
            }

      - addressable_lambda:
          name: "Fast Pulse"
          update_interval: 10ms
          lambda: |-
            static float fraction = 0.0f;
            static float step = 0.06f;
            static bool up = true;

            auto v = id(led_ring)->current_values;
            Color c(v.get_red() * 255, v.get_green() * 255, v.get_blue() * 255);

            fraction += (step * (up ? 1.0f : -1.0f));
            if (fraction >= 1.0f) { fraction = 1.0f; up = false; }
            if (fraction <= 0.0f) { fraction = 0.0f; up = true;  }

            for (int i = 0; i < it.size(); i++) {
              it[i] = Color(c.red * fraction, c.green * fraction, c.blue * fraction);
            }

      - addressable_lambda:
          name: "VA Rotate"
          update_interval: ${led_rotate_ms}
          lambda: |-
            static int pos = 0;
            const int N = it.size();
            for (int i = 0; i < N; i++) it[i] = Color(id(bg_r), id(bg_g), id(bg_b));
            it[pos % N] = Color(id(fg_r), id(fg_g), id(fg_b));
            pos = (pos + 1) % N;

      - addressable_lambda:
          name: "VA Standby"
          update_interval: ${led_standby_ms}
          lambda: |-
            const int N = it.size();
            const uint32_t now = millis();
            it.all() = Color(0,0,0);

            const int speed = atoi("${standby_speed_ms}");
            const int gap   = atoi("${standby_gap}");

            int pos1 = (now / speed) % N;
            int pos2 = (pos1 + gap) % N;

            it[pos1] = Color(
              atoi("${standby_r1}"),
              atoi("${standby_g1}"),
              atoi("${standby_b1}")
            );
            it[pos2] = Color(
              atoi("${standby_r2}"),
              atoi("${standby_g2}"),
              atoi("${standby_b2}")
            );

      - addressable_lambda:
          name: "Error Blink"
          update_interval: 120ms
          lambda: |-
            static bool on = false;
            static uint32_t last = 0;
            if (millis() - last > 240) { on = !on; last = millis(); }

            if (on) {
              it.all() = Color(
                atoi("${err_fg_r}"),
                atoi("${err_fg_g}"),
                atoi("${err_fg_b}")
              );
            } else {
              it.all() = Color(
                atoi("${err_bg_r}"),
                atoi("${err_bg_g}"),
                atoi("${err_bg_b}")
              );
            }

      - addressable_lambda:
          name: "Fiamma"
          update_interval: 35ms
          lambda: |-
            const int W = 8;
            const int H = 8;

            // 0 = nessuna rotazione
            // 1 = 90° clockwise
            // 2 = 90° counter-clockwise
            // 3 = 180°
            const int ROT = 1;   // <-- cambia qui se la fiamma non sta "in basso"

            // Serpentina per RIGHE: y pari L->R, y dispari R->L
            auto XY = [](int x, int y) -> int {
              if (y & 1) return y * W + (W - 1 - x);
              return y * W + x;
            };

            // Mappatura con rotazione
            auto MAP = [&](int x, int y) -> int {
              int px = x, py = y;
              if (ROT == 1) {        // CW
                px = W - 1 - y; py = x;
              } else if (ROT == 2) { // CCW
                px = y; py = H - 1 - x;
              } else if (ROT == 3) { // 180
                px = W - 1 - x; py = H - 1 - y;
              }
              return XY(px, py);
            };

            // RNG semplice
            auto rnd = []() -> uint32_t {
              static uint32_t s = 2463534242UL;
              s ^= s << 13; s ^= s >> 17; s ^= s << 5;
              return s;
            };

            auto qsub8 = [](uint8_t i, uint8_t j) -> uint8_t { return (i > j) ? (i - j) : 0; };
            auto qadd8 = [](uint8_t i, uint8_t j) -> uint8_t { uint16_t t = i + j; return (t > 255) ? 255 : (uint8_t)t; };

            // Heat map
            static uint8_t heat[W][H];
            static bool init = false;
            if (!init) {
              for (int x=0; x<W; x++) for (int y=0; y<H; y++) heat[x][y] = 0;
              init = true;
            }

            // Parametri fiamma (tuning)
            const uint8_t COOLING  = 65;   // più alto = più "fredda" / meno piena
            const uint8_t SPARKING = 120;  // più alto = più scintille
            const float   BRIMAX   = 0.55f; // limite luminosità (battery friendly)

            // 1) Raffredda ogni cella un po'
            for (int x=0; x<W; x++) {
              for (int y=0; y<H; y++) {
                uint8_t cooldown = (uint8_t)(rnd() % (((COOLING * 10) / H) + 2));
                heat[x][y] = qsub8(heat[x][y], cooldown);
              }

              // 2) Diffusione verso l'alto (la fiamma "sale")
              for (int y=H-1; y>=2; y--) {
                heat[x][y] = (uint8_t)((heat[x][y-1] + heat[x][y-2] + heat[x][y-2]) / 3);
              }

              // 3) Scintille dal basso (y=0..1)
              if ((rnd() % 255) < SPARKING) {
                int y = (int)(rnd() % 2);
                heat[x][y] = qadd8(heat[x][y], (uint8_t)(160 + (rnd() % 96)));
              }
            }

            // Heat -> Color (nero->rosso->giallo->bianco)
            auto heatColor = [&](uint8_t t) -> Color {
              uint8_t r, g, b;
              if (t < 85) {                 // nero -> rosso
                r = t * 3; g = 0; b = 0;
              } else if (t < 170) {         // rosso -> giallo
                uint8_t tt = t - 85;
                r = 255; g = tt * 3; b = 0;
              } else {                      // giallo -> bianco
                uint8_t tt = t - 170;
                r = 255; g = 255; b = tt * 3;
              }
              // Limite luminosità
              r = (uint8_t)(r * BRIMAX);
              g = (uint8_t)(g * BRIMAX);
              b = (uint8_t)(b * BRIMAX);
              return Color(r, g, b);
            };

            // Render: y=0 è "basso" logico -> lo disegniamo in basso reale invertendo
            for (int x=0; x<W; x++) {
              for (int y=0; y<H; y++) {
                int drawY = (H - 1 - y);  // fiamma dal basso verso l'alto
                it[MAP(x, drawY)] = heatColor(heat[x][y]);
              }
            }

      - addressable_lambda:
          name: "Plasma"
          update_interval: 30ms
          lambda: |-
            const int W = 8;
            const int H = 8;

            // Serpentina per righe: y pari L->R, y dispari R->L
            auto XY = [](int x, int y) -> int {
              if (y & 1) return y * W + (W - 1 - x);
              return y * W + x;
            };

            // HSV -> RGB (h: 0..360, s/v: 0..1)
            auto hsv2rgb = [](float h, float s, float v) -> Color {
              while (h < 0) h += 360.0f;
              while (h >= 360.0f) h -= 360.0f;
              float c = v * s;
              float x = c * (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
              float m = v - c;
              float r=0, g=0, b=0;
              if (h < 60) { r=c; g=x; b=0; }
              else if (h < 120) { r=x; g=c; b=0; }
              else if (h < 180) { r=0; g=c; b=x; }
              else if (h < 240) { r=0; g=x; b=c; }
              else if (h < 300) { r=x; g=0; b=c; }
              else { r=c; g=0; b=x; }
              return Color((uint8_t)((r+m)*255), (uint8_t)((g+m)*255), (uint8_t)((b+m)*255));
            };

            float t = millis() / 900.0f;  // velocità (più alto = più lento)

            for (int y = 0; y < H; y++) {
              for (int x = 0; x < W; x++) {
                float fx = (float)x / (W - 1);
                float fy = (float)y / (H - 1);

                float v1 = sinf((fx * 6.0f) + t);
                float v2 = sinf((fy * 6.0f) + t * 1.3f);
                float v3 = sinf(((fx + fy) * 6.0f) + t * 0.7f);
                float v = (v1 + v2 + v3) / 3.0f;   // -1..1

                float hue = (v + 1.0f) * 180.0f;   // 0..360
                // Brightness limit (battery friendly): ~10%..45%
                float bri = 0.10f + 0.35f * ((v + 1.0f) * 0.5f);

                it[XY(x, y)] = hsv2rgb(hue, 1.0f, bri);
              }
            }

      - addressable_lambda:
          name: "VA Ascolto - Radar"
          update_interval: 30ms
          lambda: |-
            const int W = 8, H = 8;
            const int ROT = 1;

            auto XY = [&](int x, int y)->int { return (y & 1) ? (y*W + (W-1-x)) : (y*W + x); };
            auto MAP = [&](int x, int y)->int {
              int px=x, py=y;
              if (ROT==1){ px=W-1-y; py=x; }
              else if (ROT==2){ px=y; py=H-1-x; }
              else if (ROT==3){ px=W-1-x; py=H-1-y; }
              return XY(px,py);
            };

            const float BRIMAX = 0.65f;
            float t = millis() / 700.0f;

            float cx = 3.5f, cy = 3.5f;
            float r0 = fmodf(t, 5.5f);  // raggio onda

            for (int y=0;y<H;y++){
              for (int x=0;x<W;x++){
                float dx=x-cx, dy=y-cy;
                float r = sqrtf(dx*dx+dy*dy);

                float pulse = 1.0f - fabsf(r - r0);     // picco sull'anello
                if (pulse < 0) pulse = 0;
                pulse = pulse * pulse;                  // più “morbido”

                float glow = 0.25f * (1.0f - r/5.0f);    // alone centro
                if (glow < 0) glow = 0;

                float a = (pulse + glow) * BRIMAX;
                if (a > 1.0f) a = 1.0f;

                uint8_t br = (uint8_t)(id(bg_r) * 0.10f);
                uint8_t bg = (uint8_t)(id(bg_g) * 0.10f);
                uint8_t bb = (uint8_t)(id(bg_b) * 0.10f);

                uint8_t fr = (uint8_t)(id(fg_r) * a);
                uint8_t fg = (uint8_t)(id(fg_g) * a);
                uint8_t fb = (uint8_t)(id(fg_b) * a);

                it[MAP(x,y)] = Color(br + fr, bg + fg, bb + fb);
              }
            }


      - addressable_lambda:
          name: "VA Penso - Neuroni"
          update_interval: 40ms
          lambda: |-
            const int W = 8, H = 8;
            const int ROT = 1;

            auto XY = [&](int x, int y)->int { return (y & 1) ? (y*W + (W-1-x)) : (y*W + x); };
            auto MAP = [&](int x, int y)->int {
              int px=x, py=y;
              if (ROT==1){ px=W-1-y; py=x; }
              else if (ROT==2){ px=y; py=H-1-x; }
              else if (ROT==3){ px=W-1-x; py=H-1-y; }
              return XY(px,py);
            };

            // Maschera "nuvola" 8x8
            static const uint8_t cloud[8] = {
              0b00111100,
              0b01111110,
              0b11111111,
              0b11111111,
              0b11111111,
              0b01111110,
              0b00111100,
              0b00011000
            };

            auto inside = [&](int x, int y)->bool { return (cloud[y] >> (7 - x)) & 0x01; };
            auto clamp01 = [&](float v)->float { if (v<0) return 0; if (v>1) return 1; return v; };

            // RNG
            auto rnd = []() -> uint32_t {
              static uint32_t s = 2463534242UL;
              s ^= s << 13; s ^= s >> 17; s ^= s << 5;
              return s;
            };

            // buffer "digital noise"
            static float n[64];
            static bool init=false;
            if(!init){ for(int i=0;i<64;i++) n[i]=0; init=true; }

            // fade noise (pensiero = più persistente)
            for(int i=0;i<64;i++){
              n[i] *= 0.90f;
              if (n[i] < 0.02f) n[i] = 0.0f;
            }

            // iniezioni random dentro la nuvola (meno frenetiche del "parlo")
            int injections = 1 + (rnd() % 3); // 1..3
            for(int k=0;k<injections;k++){
              int x, y, tries=0;
              do { x = rnd()%8; y = rnd()%8; tries++; } while(!inside(x,y) && tries < 30);
              int idx = y*W + x;
              float amp = 0.25f + 0.75f * ((rnd()%100)/100.0f);
              if (n[idx] < amp) n[idx] = amp;
            }

            // pulsazione lenta “AI processing”
            float t = millis() / 900.0f;
            float think = 0.35f + 0.65f * fabsf(sinf(t) * sinf(t*0.61f + 0.9f)); // 0.35..1.0

            // scanline verticale lenta (effetto tecnologico)
            int scan = (millis() / 170) % 8;

            float cx=3.5f, cy=3.5f;

            const float BRIMAX    = 0.70f; // battery friendly
            const float BASE_MIN  = 0.08f; // riempimento minimo
            const float BASE_MAX  = 0.52f; // riempimento massimo
            const float NOISE_GAIN= 0.75f; // intensità dei “neuroni digitali”
            const float SCAN_BOOST= 0.10f; // colonna scan

            it.all() = Color(0,0,0);

            for(int y=0;y<H;y++){
              for(int x=0;x<W;x++){
                if (!inside(x,y)) continue;

                float dx=x-cx, dy=y-cy;
                float r = sqrtf(dx*dx + dy*dy);
                float grad = 1.0f - (r / 5.0f);  // centro più acceso
                if (grad < 0) grad = 0;

                float base = (BASE_MIN + (BASE_MAX-BASE_MIN)*think) * (0.45f + 0.55f*grad);

                if (x == scan) base += SCAN_BOOST * (0.6f + 0.4f*grad);

                float noise = n[y*W + x] * NOISE_GAIN * think;

                float a_base = clamp01(base)  * BRIMAX;
                float a_fx   = clamp01(noise) * BRIMAX;

                // Palette rossa:
                // base = rosso scuro (tipo “nuvola in standby mentale”)
                // fx   = rosso acceso + un filo di arancio sui picchi
                float orange = (a_fx > 0.75f) ? 0.18f : 0.0f;

                uint8_t r8 = (uint8_t)( 255.0f * (0.10f*a_base + 0.95f*a_fx) );
                uint8_t g8 = (uint8_t)( 255.0f * (0.00f*a_base + orange*a_fx) );
                uint8_t b8 = (uint8_t)( 255.0f * (0.00f) );

                // un filo di “glow” anche quando è basso
                r8 = (uint8_t) std::min(255, (int)r8 + (int)(30.0f * a_base));

                it[MAP(x,y)] = Color(r8,g8,b8);
              }
            }


      - addressable_lambda:
          name: "VA Parlo - Voice Bars"
          update_interval: 35ms
          lambda: |-
            const int W = 8, H = 8;
            const int ROT = 1;

            auto XY = [&](int x, int y)->int { return (y & 1) ? (y*W + (W-1-x)) : (y*W + x); };
            auto MAP = [&](int x, int y)->int {
              int px=x, py=y;
              if (ROT==1){ px=W-1-y; py=x; }
              else if (ROT==2){ px=y; py=H-1-x; }
              else if (ROT==3){ px=W-1-x; py=H-1-y; }
              return XY(px,py);
            };

            // Maschera "nuvola" 8x8 (bit per riga)
            static const uint8_t cloud[8] = {
              0b00111100,
              0b01111110,
              0b11111111,
              0b11111111,
              0b11111111,
              0b01111110,
              0b00111100,
              0b00011000
            };

            auto inside = [&](int x, int y)->bool {
              return (cloud[y] >> (7 - x)) & 0x01;
            };

            auto clamp01 = [&](float v)->float { if (v<0) return 0; if (v>1) return 1; return v; };

            // RNG
            auto rnd = []() -> uint32_t {
              static uint32_t s = 2463534242UL;
              s ^= s << 13; s ^= s >> 17; s ^= s << 5;
              return s;
            };

            // Buffer "noise" per variazioni random morbide
            static float n[64];
            static bool init=false;
            if(!init){ for(int i=0;i<64;i++) n[i]=0; init=true; }

            // Fade noise
            for(int i=0;i<64;i++){
              n[i] *= 0.88f;
              if (n[i] < 0.02f) n[i] = 0.0f;
            }

            // Inietta variazioni random dentro la nuvola
            // (più parli, più "vita": qui simuliamo una parlata variabile)
            int injections = 2 + (rnd() % 3); // 2..4
            for(int k=0;k<injections;k++){
              int x, y, tries=0;
              do {
                x = rnd() % 8;
                y = rnd() % 8;
                tries++;
              } while(!inside(x,y) && tries < 30);

              int idx = y*W + x;
              // impulso casuale
              float amp = 0.35f + 0.65f * ((rnd() % 100) / 100.0f);
              if (n[idx] < amp) n[idx] = amp;
            }

            // Pulsazione “parlato”
            float t = millis() / 260.0f;
            float talk = 0.40f + 0.60f * fabsf(sinf(t) * sinf(t*0.73f + 1.1f)); // 0.4..1.0

            // Gradiente morbido (centro più acceso)
            float cx = 3.5f, cy = 3.5f;

            const float BRIMAX = 0.70f;     // alza/abbassa intensità globale
            const float BASE_MIN = 0.06f;   // base nuvola
            const float BASE_MAX = 0.22f;   // base max in “talk”
            const float NOISE_GAIN = 0.75f; // quanto contano i pixel random
            const float SPARK_TH = 0.85f;   // sopra questa soglia -> scintilla bianca

            it.all() = Color(0,0,0);

            for(int y=0;y<H;y++){
              for(int x=0;x<W;x++){
                if (!inside(x,y)) continue;

                float dx = x - cx, dy = y - cy;
                float r = sqrtf(dx*dx + dy*dy);        // 0..~5
                float grad = 1.0f - (r / 5.0f);        // centro 1, bordo ~0
                if (grad < 0) grad = 0;

                float base = (BASE_MIN + (BASE_MAX - BASE_MIN) * talk) * (0.45f + 0.55f*grad);

                float noise = n[y*W + x] * NOISE_GAIN * talk;

                float a_bg = clamp01(base) * BRIMAX;      // riempimento nuvola (bg)
                float a_fg = clamp01(noise) * BRIMAX;     // “parlato” (fg)

                // scintille (accenti di voce) -> una spruzzata di bianco
                float white = (a_fg > SPARK_TH) ? 0.18f : 0.0f;

                uint8_t r8 = (uint8_t)(id(bg_r)*a_bg + id(fg_r)*a_fg + 255.0f*white);
                uint8_t g8 = (uint8_t)(id(bg_g)*a_bg + id(fg_g)*a_fg + 255.0f*white);
                uint8_t b8 = (uint8_t)(id(bg_b)*a_bg + id(fg_b)*a_fg + 255.0f*white);

                it[MAP(x,y)] = Color(r8,g8,b8);
              }
            }

      - addressable_lambda:
          name: "VA Standby - Aurora"
          update_interval: 60ms
          lambda: |-
            const int W=8, H=8;
            const int ROT=1;

            auto XY = [&](int x, int y)->int { return (y & 1) ? (y*W + (W-1-x)) : (y*W + x); };
            auto MAP = [&](int x, int y)->int {
              int px=x, py=y;
              if (ROT==1){ px=W-1-y; py=x; }
              else if (ROT==2){ px=y; py=H-1-x; }
              else if (ROT==3){ px=W-1-x; py=H-1-y; }
              return XY(px,py);
            };

            float t = millis()/2200.0f;   // lento
            const float BRIMAX = 0.35f;   // standby super soft

            for(int y=0;y<H;y++){
              for(int x=0;x<W;x++){
                float fx = (float)x/7.0f;
                float fy = (float)y/7.0f;
                float v = sinf(fx*6.0f + t) + sinf(fy*5.0f - t*1.2f) + sinf((fx+fy)*4.0f + t*0.7f);
                v = (v/3.0f + 1.0f) * 0.5f; // 0..1

                float a = (0.08f + 0.92f*v) * BRIMAX;
                uint8_t r = (uint8_t)(id(fg_r) * a);
                uint8_t g = (uint8_t)(id(fg_g) * a);
                uint8_t b = (uint8_t)(id(fg_b) * a);

                // un filo di sfondo
                r += (uint8_t)(id(bg_r)*0.02f);
                g += (uint8_t)(id(bg_g)*0.02f);
                b += (uint8_t)(id(bg_b)*0.02f);

                it[MAP(x,y)] = Color(r,g,b);
              }
            }   
