# =========================================================
#  ESP32 Voice Assistant (HackMyHome) - Final Stable Core
#  - Wake word + Continuous conversation
#  - Centralized LED control (control_leds)
# =========================================================

substitutions:
  # -------- Identity --------
  hostname: "voice-assist-elsa"
  friendly: "HA Voice Assist Elsa"
  ActivateChat: "Chat Attiva"

  # -------- Boot --------
  # Home Assistant boot config
  ha_base_url: "http://192.168.31.182:8123"
  boot_sound_path: "/local/mac_dong_boot.mp3"
  boot_sound_delay: "6s"

  # -------- WiFi --------
  ip: "192.168.31.20"
  gateway: "192.168.31.1"
  subnet: "255.255.255.0"
  dns: "192.168.1.1"

  # -------- I2S pins --------
  i2s_bclk_pin: "GPIO9"
  i2s_lrclk_pin: "GPIO10"
  i2s_din_pin:  "GPIO8"
  i2s_dout_pin: "GPIO3"

  # -------- Audio tuning --------
  sample_rate_hz: "44100"
  mic_gain_factor: "4"

  # -------- Models --------
  wake_word_model: "hey_jarvis"

  # -------- LED ring --------
  led_pin: "GPIO11"
  led_count: "16"
  led_rotate_ms: "100ms"
  led_standby_ms: "50ms"

  # Standby (two dots)
  standby_speed_ms: "90"
  standby_gap: "3"
  standby_r1: "120"
  standby_g1: "0"
  standby_b1: "120"
  standby_r2: "50"
  standby_g2: "0"
  standby_b2: "50"

  # Listening dot + background
  listen_fg_r: "0"
  listen_fg_g: "200"
  listen_fg_b: "0"
  listen_bg_r: "0"
  listen_bg_g: "0"
  listen_bg_b: "60"

  # Thinking
  think_fg_r: "200"
  think_fg_g: "0"
  think_fg_b: "20"
  think_bg_r: "0"
  think_bg_g: "0"
  think_bg_b: "60"

  # Speaking
  speak_fg_r: "255"
  speak_fg_g: "200"
  speak_fg_b: "0"
  speak_bg_r: "120"
  speak_bg_g: "0"
  speak_bg_b: "0"

  # Error
  err_fg_r: "255"
  err_fg_g: "0"
  err_fg_b: "0"
  err_bg_r: "10"
  err_bg_g: "0"
  err_bg_b: "0"

  # -------- Voice Assistant Phases --------
  voice_assist_idle_phase_id: "1"
  voice_assist_listening_phase_id: "2"
  voice_assist_thinking_phase_id: "3"
  voice_assist_replying_phase_id: "4"
  voice_assist_not_ready_phase_id: "10"
  voice_assist_error_phase_id: "11"
  voice_assist_muted_phase_id: "12"
  voice_assist_timer_finished_phase_id: "20"

globals:
  - id: init_in_progress
    type: bool
    restore_value: false
    initial_value: "true"
  - id: voice_assistant_phase
    type: int
    restore_value: false
    initial_value: ${voice_assist_not_ready_phase_id}

  - id: fg_r
    type: int
    restore_value: false
    initial_value: "0"
  - id: fg_g
    type: int
    restore_value: false
    initial_value: "0"
  - id: fg_b
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_r
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_g
    type: int
    restore_value: false
    initial_value: "0"
  - id: bg_b
    type: int
    restore_value: false
    initial_value: "0"

  - id: ts_va_listening_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_vad_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_stt_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_tts_start_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_reply_done_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: ts_va_end_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: va_turn
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: question
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: answer
    type: std::string
    restore_value: no
    initial_value: '""'

esphome:
  name: ${hostname}
  friendly_name: ${friendly}
  project:
    name: HackMyHome.VoiceAssist
    version: '2.3.0'
  on_boot:
    priority: 600
    then:
      - logger.log:
          level: INFO
          format: "=== BOOT START"
      - media_player.play_media:
          id: speaker_media_player
          media_url: "${ha_base_url}${boot_sound_path}"
          announcement: false
      - logger.log:
          level: INFO
          format: "=== BOOT - Tone done"
      - delay: ${boot_sound_delay}
      - if:
          condition:
            not:
              - micro_wake_word.is_running:
          then:
            - micro_wake_word.start:
            - delay: 200ms
            - logger.log:
                level: INFO
                format: "==== BOOT - WakeWord: Start"
      - logger.log:
          level: INFO
          format: "=== BOOT END"
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: id(init_in_progress) = false;
  on_shutdown:
    then:
      - logger.log:
          level: INFO
          format: "SHUTDOWN: stop audio and led ring"
      - media_player.stop:
          id: speaker_media_player
      - micro_wake_word.stop:
      - voice_assistant.stop:

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"

      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"

logger:
  level: INFO

psram:
  mode: octal
  speed: 80MHz

wifi:
  ssid: "your_internet_ssid"
  password: "your_password"
  fast_connect: true
  manual_ip:
    static_ip: ${ip}
    gateway: ${gateway}
    subnet: ${subnet}
    dns1: ${dns}
    dns2: 8.8.8.8
  ap:
    ssid: "${friendly} Fallback"
    password: "insert_ap_password"
  on_connect:
    then:
      - logger.log:
          level: INFO
          format: "WiFi: connected"
  on_disconnect:
    then:
      - logger.log:
          level: INFO
          format: "WiFi: disconnected"

api:
  encryption:
    key: "your_api_key"

ota:
  - platform: esphome
    password: "your_ota_password"

captive_portal:

button:
  - platform: factory_reset
    id: factory_reset_btn
    internal: true

i2s_audio:
  - id: i2s_output
    i2s_bclk_pin:
      number: ${i2s_bclk_pin}
    i2s_lrclk_pin:
      number: ${i2s_lrclk_pin}

microphone:
  - platform: i2s_audio
    id: box_mic
    i2s_audio_id: i2s_output
    i2s_din_pin: ${i2s_din_pin}
    adc_type: external
    channel: left

speaker:
  - platform: i2s_audio
    id: box_speaker
    i2s_dout_pin: ${i2s_dout_pin}
    dac_type: external
    sample_rate: ${sample_rate_hz}
    channel: stereo
    buffer_duration: 100ms

media_player:
  - platform: speaker
    name: "${friendly} Speaker"
    id: speaker_media_player
    volume_increment: 0.1
    task_stack_in_psram: true
    announcement_pipeline:
      speaker: box_speaker
      format: FLAC
      sample_rate: 48000
      num_channels: 1
    on_announcement:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: ANNOUNCEMENT ===="
      # Stop the wake word (mWW or VA) if the mic is capturing
      - if:
          condition:
            - microphone.is_capturing:
          then:
            - script.execute: stop_wake_word
            # Ensure VA stops before moving on
            - if:
                condition:
                  - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
                then:
                  - wait_until:
                      - not:
                          voice_assistant.is_running:
      # Since VA isn't running, this is user-intiated media playback. Draw the mute display
      - if:
          condition:
            not:
              voice_assistant.is_running:
          then:
            - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
      - script.execute: control_leds

    on_idle:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: IDLE ===="
      - if:
          condition:
            not:
              - voice_assistant.is_running:
          then:
            - logger.log:
                level: INFO
                format: "==== MediaPlayer: IDLE - RESTART WAKE WORD ===="
            - script.execute: start_wake_word
      - script.execute: control_leds

    on_play:
      - logger.log:
          level: INFO
          format: "==== MediaPlayer: PLAY ===="
      - script.execute: control_leds

micro_wake_word:
  id: mww
  stop_after_detection: false
  microphone:
    microphone: box_mic
    channels: 0
    gain_factor: ${mic_gain_factor}

  models:
    - model: ${wake_word_model}
      id: main_ww
  on_wake_word_detected:
    - logger.log:
        level: INFO
        format: "==== MicroWakeWord: DETECTED ===="
    - voice_assistant.start_continuous:
    - script.execute: control_leds

voice_assistant:
  id: va
  microphone: box_mic
  media_player: speaker_media_player
  micro_wake_word: mww
  noise_suppression_level: 2
  auto_gain: 31dBFS
  volume_multiplier: 2.0
  on_listening:
    - lambda: id(ts_va_listening_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: LISTENING (t=%u ms)"
        args: ['(unsigned) id(ts_va_listening_ms)']
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
    - text_sensor.template.publish:
        id: text_request
        state: "..."
    - text_sensor.template.publish:
        id: text_response
        state: "..."
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(ts_va_vad_end_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: STT VAD END (t=%u ms)"
        args: ['(unsigned) id(ts_va_vad_end_ms)']
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_stt_end:
    - lambda: |-
        id(question) = x.c_str();
        id(ts_va_stt_end_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: STT END (t=%u ms)"
        args: ['(unsigned) id(ts_va_stt_end_ms)']
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant - Question: %s"
        args: ['id(question).c_str()']
    - text_sensor.template.publish:
        id: text_request
        state: !lambda return x;
    - script.execute: control_leds
  on_tts_start:
    - lambda: |-
        id(answer) = x.c_str();
        id(ts_va_tts_start_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TTS START (t=%u ms)"
        args: ['(unsigned) id(ts_va_tts_start_ms)']
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant - Answer %s"
        args: ['id(answer).c_str()']
    - text_sensor.template.publish:
        id: text_response
        state: !lambda return x;
    - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
    # "modalità silenziosa" -> esci
    - if:
        condition:
          lambda: |-
            std::string t = x;
            for (auto &c : t) c = tolower((unsigned char)c);
            return (t.find("modalità silenziosa") != std::string::npos);
        then:
          - delay: 500ms
          - voice_assistant.stop
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: Voice Assistant: Stop"
          - micro_wake_word.start:
          - delay: 200ms
          - logger.log:
              level: INFO
              format: "==== Modalita Silenziosa: WakeWord: Start"
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_end:
    # Wait a short amount of time to see if an announcement starts
    - lambda: id(ts_va_reply_done_ms) = millis();
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: END (t=%u ms)"
        args: ['(unsigned) id(ts_va_reply_done_ms)']
    - wait_until:
        condition:
          - media_player.is_announcing:
        timeout: 0.5s
        
    # Announcement is finished and the I2S bus is free
    - wait_until:
        - and:
            - not:
                media_player.is_announcing:
            - not:
                speaker.is_playing:
    - lambda: id(ts_va_reply_done_ms) = millis();

    # Restart only mWW if enabled; streaming wake words automatically restart
    - if:
        condition:
          - lambda: return id(wake_word_engine_location).state == "On device";
        then:
          - lambda: id(va).set_use_wake_word(false);
          - if:
              condition:
                not:
                  - micro_wake_word.is_running:
              then:
                - micro_wake_word.start:
                - delay: 200ms
                - logger.log:
                    level: INFO
                    format: "==== WakeWord: Start"

    # Clear text sensors
    - text_sensor.template.publish:
        id: text_request
        state: ""
    - text_sensor.template.publish:
        id: text_response
        state: ""
    - script.execute: control_leds
    - lambda: id(ts_va_end_ms) = millis();
    - script.execute: va_timing_report
  on_error:
    - logger.log:
        level: ERROR
        format: "==== VoiceAssistant: ERROR: %s - %s"
        args: [ 'code.c_str()', 'message.c_str()' ]
    # Se è solo "no text", non andare in errore
    - if:
        condition:
          lambda: return code == "stt-no-text-recognized";
        then:
          - logger.log:
              level: INFO
              format: "==== VoiceAssistant: no-text -> Stop&Start"
          - if:
              condition:
                - micro_wake_word.is_running:
              then:
                - micro_wake_word.stop
                - delay: 500ms
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: no-text -> Stop WakeWord"
          - if:
              condition:
                - voice_assistant.is_running:
              then:
                - voice_assistant.stop
                - delay: 500ms
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: no-text -> Stop Voice Assistant"
          - logger.log:
              level: INFO
              format: "==== VoiceAssistant: no-text -> Start"
          - voice_assistant.start_continuous
          - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
          - script.execute: control_leds
        else:
          # Se è "intent-failed - Unexpected error during intent recognition", restart
          - if:
              condition:
                lambda: return code == "intent-failed";
              then:
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: intent error -> Stop&Start"
                - if:
                    condition:
                      - micro_wake_word.is_running:
                    then:
                      - micro_wake_word.stop
                      - delay: 500ms
                      - logger.log:
                          level: INFO
                          format: "==== VoiceAssistant: intent-error -> Stop WakeWord"
                - if:
                    condition:
                      - voice_assistant.is_running:
                    then:
                      - voice_assistant.stop
                      - delay: 500ms
                      - logger.log:
                          level: INFO
                          format: "==== VoiceAssistant: intent-error -> Stop Voice Assistant"
                - logger.log:
                    level: INFO
                    format: "==== VoiceAssistant: inten-error -> Start"
                - voice_assistant.start_continuous
                - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
                - script.execute: control_leds
        # qui lasci la tua gestione "vera" degli errori
    - if:
        condition:
          lambda: return !id(init_in_progress);
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};

  on_client_connected:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: CLIENT CONNECTED ===="
    - lambda: id(init_in_progress) = false;
    - script.execute: start_wake_word
    - script.execute: control_leds
  on_client_disconnected:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: DISCONNECTED ===="
    - script.execute: stop_wake_word
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_timer_started:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER STARTED ===="
    - script.execute: control_leds
  on_timer_cancelled:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER CANCELLED ===="
    - script.execute: control_leds
  on_timer_updated:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER UPDATED ===="
    - script.execute: control_leds
  on_timer_tick:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER TICK ===="
    - script.execute: control_leds
  on_timer_finished:
    - logger.log:
        level: INFO
        format: "==== VoiceAssistant: TIMER FINISHED ===="
    - switch.turn_on: timer_ringing
    - wait_until:
        media_player.is_announcing:
    - lambda: id(voice_assistant_phase) = ${voice_assist_timer_finished_phase_id};
    - script.execute: control_leds

script:
  - id: va_timing_report
    mode: restart
    then:
      - lambda: |-
          auto ms_to_s = [](uint32_t ms) -> float { return ((float) ms) / 1000.0f; };

          const uint32_t t_listen = id(ts_va_listening_ms);
          const uint32_t t_vad    = id(ts_va_vad_end_ms);
          const uint32_t t_stt    = id(ts_va_stt_end_ms);       // "ha capito cosa chiedo"
          const uint32_t t_tts    = id(ts_va_tts_start_ms);
          const uint32_t t_done   = id(ts_va_reply_done_ms);    // fine parlato reale
          const uint32_t t_end    = id(ts_va_end_ms);           // fine on_end (cleanup)

          // Report principale: STT_END -> SPEECH_END
          if (t_stt == 0 || t_tts == 0 || t_done == 0 || t_done <= t_stt || t_tts < t_stt) {
            ESP_LOGI("va_timing", "VA Timing: incomplete (stt=%u tts=%u done=%u)", t_stt, t_tts, t_done);
            return;
          }

          const uint32_t total_ms = t_done - t_stt;
          const uint32_t think_ms = t_tts - t_stt;
          const uint32_t speak_ms = t_done - t_tts;

          auto pct = [&](uint32_t part_ms) -> float {
            return (total_ms > 0) ? (100.0f * ((float) part_ms) / (float) total_ms) : 0.0f;
          };

          ESP_LOGI("va_timing", "=== VA Timing Report (STT_END -> SPEECH_END) ===");
          ESP_LOGI("va_timing", "Total: %.2fs", ms_to_s(total_ms));
          ESP_LOGI("va_timing", "Thinking (STT_END->TTS_START): %.2fs (%.1f%%)", ms_to_s(think_ms), pct(think_ms));
          ESP_LOGI("va_timing", "Speaking (TTS_START->SPEECH_END): %.2fs (%.1f%%)", ms_to_s(speak_ms), pct(speak_ms));

          // Extra (non inclusi nel totale richiesto, ma utili per debug)
          if (t_listen && t_vad && t_vad > t_listen) {
            ESP_LOGI("va_timing", "Pre: Listening->VAD_END: %.2fs", ms_to_s(t_vad - t_listen));
          }
          if (t_vad && t_stt && t_stt > t_vad) {
            ESP_LOGI("va_timing", "Pre: VAD_END->STT_END: %.2fs", ms_to_s(t_stt - t_vad));
          }
          if (t_end && t_end > t_done) {
            ESP_LOGI("va_timing", "Post: SPEECH_END->END(cleanup): %.2fs", ms_to_s(t_end - t_done));
          }

          ESP_LOGI("va_timing", "==============================================");

  # Starts either mWW or the streaming wake word, depending on the configured location
  - id: start_wake_word
    then:
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - if:
                condition:
                  not:
                    - micro_wake_word.is_running:
                then:
                  - micro_wake_word.start:
                  - delay: 200ms
                  - logger.log:
                      level: INFO
                      format: "==== WakeWord: Start"
      - if:
          condition:
            and:
              - not:
                  - voice_assistant.is_running:
              - lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous:
  # Stops either mWW or the streaming wake word, depending on the configured location
  - id: stop_wake_word
    then:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop:
      - if:
          condition:
            lambda: return id(wake_word_engine_location).state == "On device";
          then:
            - micro_wake_word.stop:
  # Set the voice assistant phase to idle or muted, depending on if the software mute switch is activated
  - id: set_idle_or_mute_phase
    then:
      - if:
          condition:
            voice_assistant.is_running:
          then:
            - if:
                condition:
                  switch.is_off: mute
                then:
                  - logger.log:
                      level: INFO
                      format: "==== MICROPHONE UN-MUTE ==="
                  - if:
                      condition:
                        - voice_assistant.is_running:
                      then:
                        - voice_assistant.stop
                        - delay: 500ms
                        - logger.log:
                            level: INFO
                            format: "==== MICROPHONE UN-MUTE -> Stop Voice Assistant"
                  - if:
                      condition:
                        not:
                          - micro_wake_word.is_running:
                      then:
                        - micro_wake_word.start
                        - delay: 500ms
                        - logger.log:
                            level: INFO
                            format: "==== MICROPHONE UN-MUTE -> Start WakeWord"
                  - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                else:
                  - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
                  - logger.log:
                      level: INFO
                      format: "==== MICROPHONE MUTE ==="
                  - if:
                      condition:
                        - micro_wake_word.is_running:
                      then:
                        - micro_wake_word.stop
                        - delay: 500ms
                        - logger.log:
                            level: INFO
                            format: "==== MICROPHONE MUTE -> Stop WakeWord"
                  - if:
                      condition:
                        - voice_assistant.is_running:
                      then:
                        - voice_assistant.stop
                        - delay: 500ms
                        - logger.log:
                            level: INFO
                            format: "==== MICROPHONE MUTE -> Stop Voice Assistant"
                  - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
            - script.execute: control_leds

  - id: control_leds
    mode: restart
    then:
      # Se siamo ancora in init → boot scan
      - if:
          condition:
            lambda: return id(init_in_progress);
          then:
            - lambda: |-
                auto call = id(led_ring).turn_on();
                call.set_brightness(0.55f);
                call.set_effect("Fast Pulse");
                call.perform();
          else:
            # Se manca WiFi o API → standby (o boot scan, scegli tu)
            - if:
                condition:
                  and:
                    - wifi.connected:
                    - api.connected:
                then:
                  - lambda: |-
                      // helper: applica un effetto + brightness (+ opzionale rgb)
                      auto apply_effect = [&](const char *effect, float br, bool set_rgb,
                                              float r, float g, float b) {
                        auto call = id(led_ring).turn_on();
                        call.set_brightness(br);
                        call.set_effect(effect);
                        if (set_rgb) call.set_rgb(r, g, b);
                        call.perform();
                      };

                      const int phase = id(voice_assistant_phase);

                      switch (phase) {

                        case ${voice_assist_listening_phase_id}: {
                          id(fg_r) = atoi("${listen_fg_r}");
                          id(fg_g) = atoi("${listen_fg_g}");
                          id(fg_b) = atoi("${listen_fg_b}");
                          id(bg_r) = atoi("${listen_bg_r}");
                          id(bg_g) = atoi("${listen_bg_g}");
                          id(bg_b) = atoi("${listen_bg_b}");
                          apply_effect("VA Rotate", 0.65f, false, 0, 0, 0);
                          break;
                        }

                        case ${voice_assist_thinking_phase_id}: {
                          id(fg_r) = atoi("${think_fg_r}");
                          id(fg_g) = atoi("${think_fg_g}");
                          id(fg_b) = atoi("${think_fg_b}");
                          id(bg_r) = atoi("${think_bg_r}");
                          id(bg_g) = atoi("${think_bg_g}");
                          id(bg_b) = atoi("${think_bg_b}");
                          apply_effect("VA Rotate", 0.70f, false, 0, 0, 0);
                          break;
                        }

                        case ${voice_assist_replying_phase_id}: {
                          id(fg_r) = atoi("${speak_fg_r}");
                          id(fg_g) = atoi("${speak_fg_g}");
                          id(fg_b) = atoi("${speak_fg_b}");
                          id(bg_r) = atoi("${speak_bg_r}");
                          id(bg_g) = atoi("${speak_bg_g}");
                          id(bg_b) = atoi("${speak_bg_b}");
                          apply_effect("VA Rotate", 0.70f, false, 0, 0, 0);
                          break;
                        }

                        case ${voice_assist_error_phase_id}: {
                          apply_effect("Error Blink", 0.90f, false, 0, 0, 0);
                          break;
                        }

                        case ${voice_assist_muted_phase_id}: {
                          const float r = atoi("${speak_bg_r}") / 255.0f;
                          const float g = atoi("${speak_bg_g}") / 255.0f;
                          const float b = atoi("${speak_bg_b}") / 255.0f;
                          apply_effect("Slow Pulse", 0.35f, true, r, g, b);
                          break;
                        }

                        case ${voice_assist_not_ready_phase_id}: {
                          apply_effect("VA Standby", 0.35f, false, 0, 0, 0);
                          break;
                        }

                        case ${voice_assist_timer_finished_phase_id}: {
                          const float r = atoi("${speak_fg_r}") / 255.0f;
                          const float g = atoi("${speak_fg_g}") / 255.0f;
                          const float b = atoi("${speak_fg_b}") / 255.0f;
                          apply_effect("Fast Pulse", 0.95f, true, r, g, b);
                          break;
                        }

                        default: {
                          apply_effect("VA Standby", 0.35f, false, 0, 0, 0);
                          break;
                        }
                      }
                else:
                  - lambda: |-
                      auto call = id(led_ring).turn_on();
                      call.set_brightness(0.35f);
                      call.set_effect("VA Standby");
                      call.perform();

switch:
  - platform: gpio
    name: Speaker Enable
    pin: GPIO46
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config
    disabled_by_default: true
  - platform: template
    name: Mute
    id: mute
    icon: "mdi:microphone-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_off:
      - microphone.unmute:
      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    on_turn_on:
      - microphone.mute:
      - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      # Turn off the repeat mode and disable the pause between playlist items
      - lambda: |-
              id(speaker_media_player)
                ->make_call()
                .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
                .set_announcement(true)
                .perform();
              id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);
      # Stop playing the alarm
      - media_player.stop:
          announcement: true
    on_turn_on:
      # Turn on the repeat mode and pause for 1000 ms between playlist items/repeats
      - lambda: |-
            id(speaker_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(speaker_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 1000);
      - delay: 15min
      - switch.turn_off: timer_ringing

select:
  - platform: template
    entity_category: config
    name: Wake word engine location
    id: wake_word_engine_location
    icon: "mdi:account-voice"
    optimistic: true
    restore_value: true
    options:
      - In Home Assistant
      - On device
    initial_option: On device
    on_value:
      - if:
          condition:
            lambda: return !id(init_in_progress);
          then:
            - wait_until:
                lambda: return id(voice_assistant_phase) == ${voice_assist_muted_phase_id} || id(voice_assistant_phase) == ${voice_assist_idle_phase_id};
            - if:
                condition:
                  lambda: return x == "In Home Assistant";
                then:
                  - micro_wake_word.stop
                  - delay: 500ms
                  - if:
                      condition:
                        switch.is_off: mute
                      then:
                        - lambda: id(va).set_use_wake_word(true);
                        - voice_assistant.start_continuous:
            - if:
                condition:
                  lambda: return x == "On device";
                then:
                  - lambda: id(va).set_use_wake_word(false);
                  - voice_assistant.stop
                  - delay: 500ms
                  - if:
                      condition:
                        switch.is_off: mute
                      then:
                        - if:
                            condition:
                              not:
                                - micro_wake_word.is_running:
                            then:
                              - micro_wake_word.start:
                              - delay: 200ms
                              - logger.log:
                                  level: INFO
                                  format: "==== WakeWord: Start"

text_sensor:
  - id: text_request
    platform: template
    on_value:
      lambda: |-
        if(id(text_request).state.length()>32) {
          std::string name = id(text_request).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_request).state = (truncated+"...").c_str();
        }

  - id: text_response
    platform: template
    on_value:
      lambda: |-
        if(id(text_response).state.length()>32) {
          std::string name = id(text_response).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_response).state = (truncated+"...").c_str();
        }

light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    rgb_order: GRB
    id: led_ring
    name: "LED Ring"
    pin: ${led_pin}
    num_leds: ${led_count}
    restore_mode: ALWAYS_OFF
    default_transition_length: 0s
    effects:

      - addressable_lambda:
          name: "Slow Pulse"
          update_interval: 40ms
          lambda: |-
            // ====== TUNING ======
            const float SPEED_LEDS_PER_SEC = 7.0f;          // velocità rotazione
            const float TAIL_LEDS          = 2*it.size()/3; // coda (in led)
            const float TRANSITION_SEC     = 2.2f;          // durata crossfade colore
            const float SAT                = 0.95f;         // saturazione colori
            const float VAL                = 1.00f;         // luminosità colori
            // =====================

            auto smoothstep = [](float x) -> float {
              x = (x < 0.0f) ? 0.0f : (x > 1.0f ? 1.0f : x);
              return x * x * (3.0f - 2.0f * x);
            };

            auto hsv_to_rgb = [](float h, float s, float v) -> Color {
              h = fmodf(h, 360.0f);
              if (h < 0) h += 360.0f;

              float c = v * s;
              float x = c * (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
              float m = v - c;

              float rp=0, gp=0, bp=0;
              if      (h < 60)  { rp=c; gp=x; bp=0; }
              else if (h < 120) { rp=x; gp=c; bp=0; }
              else if (h < 180) { rp=0; gp=c; bp=x; }
              else if (h < 240) { rp=0; gp=x; bp=c; }
              else if (h < 300) { rp=x; gp=0; bp=c; }
              else              { rp=c; gp=0; bp=x; }

              uint8_t r = (uint8_t) ((rp + m) * 255.0f);
              uint8_t g = (uint8_t) ((gp + m) * 255.0f);
              uint8_t b = (uint8_t) ((bp + m) * 255.0f);
              return Color(r, g, b);
            };

            auto lerp_color = [](const Color &a, const Color &b, float t) -> Color {
              t = (t < 0.0f) ? 0.0f : (t > 1.0f ? 1.0f : t);
              uint8_t r = (uint8_t) (a.red   + (b.red   - a.red)   * t);
              uint8_t g = (uint8_t) (a.green + (b.green - a.green) * t);
              uint8_t b2= (uint8_t) (a.blue  + (b.blue  - a.blue)  * t);
              return Color(r, g, b2);
            };

            auto random_nice_color = [&]() -> Color {
              float hue = (float)(random_uint32() % 360);
              return hsv_to_rgb(hue, SAT, VAL);
            };

            static bool init = false;
            static uint32_t last_ms = 0;

            static float pos = 0.0f;            // posizione cometa
            static float tcol = 0.0f;           // 0..1 progress transizione colore
            static Color c_from(255, 0, 0);
            static Color c_to(0, 255, 255);

            uint32_t now = millis();
            float dt = 0.0f;
            if (last_ms != 0) dt = (now - last_ms) / 1000.0f;
            last_ms = now;

            if (!init) {
              c_from = random_nice_color();
              c_to   = random_nice_color();
              init = true;
            }

            // Avanza posizione
            if (dt > 0.0f) {
              pos += SPEED_LEDS_PER_SEC * dt;
              float n = (float) it.size();
              pos = fmodf(pos, n);
              if (pos < 0) pos += n;
            }

            // Transizione colore
            if (dt > 0.0f) tcol += dt / TRANSITION_SEC;
            if (tcol >= 1.0f) {
              tcol = 0.0f;
              c_from = c_to;
              c_to = random_nice_color();
            }

            float e = smoothstep(tcol);
            Color c = lerp_color(c_from, c_to, e);

            // Disegna cometa con coda (wrap su anello)
            int n = it.size();
            for (int i = 0; i < n; i++) {
              float d = fabsf((float)i - pos);
              d = fminf(d, (float)n - d);   // distanza su anello (wrap)
              float b = 1.0f - (d / TAIL_LEDS);
              if (b < 0.0f) b = 0.0f;
              b = b * b; // morbida (easing della coda)

              it[i] = Color(
                (uint8_t)(c.red   * b),
                (uint8_t)(c.green * b),
                (uint8_t)(c.blue  * b)
              );
            }

      - addressable_lambda:
          name: "Fast Pulse"
          update_interval: 10ms
          lambda: |-
            static float fraction = 0.0f;
            static float step = 0.06f;
            static bool up = true;

            auto v = id(led_ring)->current_values;
            Color c(v.get_red() * 255, v.get_green() * 255, v.get_blue() * 255);

            fraction += (step * (up ? 1.0f : -1.0f));
            if (fraction >= 1.0f) { fraction = 1.0f; up = false; }
            if (fraction <= 0.0f) { fraction = 0.0f; up = true;  }

            for (int i = 0; i < it.size(); i++) {
              it[i] = Color(c.red * fraction, c.green * fraction, c.blue * fraction);
            }

      - addressable_lambda:
          name: "VA Rotate"
          update_interval: ${led_rotate_ms}
          lambda: |-
            static int pos = 0;
            const int N = it.size();
            for (int i = 0; i < N; i++) it[i] = Color(id(bg_r), id(bg_g), id(bg_b));
            it[pos % N] = Color(id(fg_r), id(fg_g), id(fg_b));
            pos = (pos + 1) % N;

      - addressable_lambda:
          name: "VA Standby"
          update_interval: ${led_standby_ms}
          lambda: |-
            const int N = it.size();
            const uint32_t now = millis();
            it.all() = Color(0,0,0);

            const int speed = atoi("${standby_speed_ms}");
            const int gap   = atoi("${standby_gap}");

            int pos1 = (now / speed) % N;
            int pos2 = (pos1 + gap) % N;

            it[pos1] = Color(
              atoi("${standby_r1}"),
              atoi("${standby_g1}"),
              atoi("${standby_b1}")
            );
            it[pos2] = Color(
              atoi("${standby_r2}"),
              atoi("${standby_g2}"),
              atoi("${standby_b2}")
            );

      - addressable_lambda:
          name: "Error Blink"
          update_interval: 120ms
          lambda: |-
            static bool on = false;
            static uint32_t last = 0;
            if (millis() - last > 240) { on = !on; last = millis(); }

            if (on) {
              it.all() = Color(
                atoi("${err_fg_r}"),
                atoi("${err_fg_g}"),
                atoi("${err_fg_b}")
              );
            } else {
              it.all() = Color(
                atoi("${err_bg_r}"),
                atoi("${err_bg_g}"),
                atoi("${err_bg_b}")
              );
            }
