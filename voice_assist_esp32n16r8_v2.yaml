# =========================================================
#  ESP32 Voice Assistant (HackMyHome) - GitHub Ready Core
#  - Wake word + Continuous + Stop Word on-demand
#  - State machine + Boot/WiFi UX + LED ring states
#  - All tunables in substitutions
#  - Inspired by AshayRey code
# ==================== Hack My Home =======================

substitutions:
  # -------- Identity --------
  hostname: "voice-assist-elsa"
  friendly: "HA Voice Assist Elsa"
  ActivateChat: "Chat Attiva"

  # -------- WiFi (generic) --------
  wifi_output_power: "8.5dB"

  # -------- I2S pins --------
  i2s_bclk_pin:  "GPIO9"
  i2s_lrclk_pin: "GPIO10"
  i2s_din_pin:   "GPIO8"
  i2s_dout_pin:  "GPIO3"

  # -------- Audio tuning --------
  sample_rate_hz: "44100"
  mic_gain_factor: "4"
  va_noise_suppression: "1"
  va_auto_gain: "31dBFS"
  va_volume_multiplier: "4.0"

  # -------- Mixer / Ducking --------
  ducking_db_default: "18"      # 0..30
  ducking_apply_s: "0.20s"
  ducking_release_s: "1.00s"

  # -------- Timings --------
  boot_anim_s: "8s"             # boot animation duration
  init_fail_safe_s: "30s"       # if HA/API never connects
  listening_timeout_s: "3s"     # after wake word, if no speech

  # -------- Models --------
  wake_word_model: "hey_jarvis" # your local model name
  stop_word_enabled: "true"     # true/false
  stop_word_model_id: "stop"    # internal model id label (used below)

  # -------- Wake sensitivity cutoffs (0..255) --------
  ww_cutoff_slight:  "217"
  ww_cutoff_slightp: "191"
  ww_cutoff_mod:     "176"
  ww_cutoff_very:    "143"

  # -------- LED ring --------
  led_pin: "GPIO11"
  led_count: "16"
  led_rotate_ms: "70ms"
  led_standby_ms: "40ms"

  # Standby (two dots)
  standby_speed_ms: "90"        # millis divisor
  standby_gap: "3"
  standby_r1: "120"
  standby_g1: "0"
  standby_b1: "120"
  standby_r2: "50"
  standby_g2: "0"
  standby_b2: "50"

  # Listening dot + background
  listen_fg_r: "0"
  listen_fg_g: "200"
  listen_fg_b: "0"
  listen_bg_r: "0"
  listen_bg_g: "0"
  listen_bg_b: "60"

  # Thinking
  think_fg_r: "200"
  think_fg_g: "0"
  think_fg_b: "20"
  think_bg_r: "0"
  think_bg_g: "0"
  think_bg_b: "60"

  # Speaking
  speak_fg_r: "255"
  speak_fg_g: "200"
  speak_fg_b: "0"
  speak_bg_r: "120"
  speak_bg_g: "0"
  speak_bg_b: "0"

  # Error
  err_fg_r: "255"
  err_fg_g: "0"
  err_fg_b: "0"
  err_bg_r: "10"
  err_bg_g: "0"
  err_bg_b: "0"

  # -------- State Machine IDs --------
  voice_assist_idle_phase_id: '1'
  voice_assist_listening_phase_id: '2'
  voice_assist_thinking_phase_id: '3'
  voice_assist_replying_phase_id: '4'
  voice_assist_not_ready_phase_id: '10'
  voice_assist_error_phase_id: '11'
  voice_assist_muted_phase_id: '12'

esphome:
  name: ${hostname}
  friendly_name: ${friendly}
  project:
    name: HackMyHome.VoiceAssist
    version: '2.1.0'
  on_boot:
    priority: 600
    then:
      - lambda: |-
          id(init_in_progress) = true;
          id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
      - light.turn_on:
          id: led_ring
          blue: 0%
          red: 0%
          green: 100%
          brightness: 50%
          effect: "scanning"
      - delay: ${boot_anim_s}
      # Fail-safe: if HA never connects, stop boot phase anyway
      - delay: ${init_fail_safe_s}
      - lambda: id(init_in_progress) = false;

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y" 

psram:
  mode: octal
  speed: 80MHz
  
logger:
  level: DEBUG

api:
#  encryption:
#    key: !secret api_key 
  actions:
    - action: start_va
      then:
        - voice_assistant.start
    - action: stop_va
      then:
        - voice_assistant.stop

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: ${wifi_output_power}
  ap:
    ssid: "${friendly} Fallback"
    password: !secret wifi_ap_password
  on_connect:
    - light.turn_off:
        id: led_ring      
  on_disconnect:
    - light.turn_on:
        id: led_ring
        blue: 0%
        red: 50%
        green: 0%
        brightness: 98%
        effect: "Fast Pulse"
        
captive_portal:

# -----------------------------
# GLOBALS / FLAGS (point C)
# -----------------------------
globals:
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'

  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}

  - id: is_tts_active
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: question_flag
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: last_wake_word
    type: std::string
    restore_value: no
    initial_value: '""'

  # LED colors runtime
  - id: fg_r
    type: int
    initial_value: "0"
  - id: fg_g
    type: int
    initial_value: "0"
  - id: fg_b
    type: int
    initial_value: "0"
  - id: bg_r
    type: int
    initial_value: "0"
  - id: bg_g
    type: int
    initial_value: "0"
  - id: bg_b
    type: int
    initial_value: "0"

time:
  - platform: sntp
    id: sntp_time

# -----------------------------
# I2S BUS + MIC + SPEAKER
# -----------------------------
i2s_audio:
  - id: i2s_in_out
    i2s_bclk_pin: ${i2s_bclk_pin}
    i2s_lrclk_pin: ${i2s_lrclk_pin}

microphone:
  - platform: i2s_audio
    id: mic_in
    i2s_audio_id: i2s_in_out
    i2s_din_pin: ${i2s_din_pin}
    adc_type: external
    channel: left

speaker:
  - platform: i2s_audio
    id: spk_hw
    i2s_audio_id: i2s_in_out
    dac_type: external
    i2s_dout_pin: ${i2s_dout_pin}
    sample_rate: ${sample_rate_hz}
    channel: stereo
    buffer_duration: 90ms

  - platform: mixer
    id: spk_mixer
    output_speaker: spk_hw
    task_stack_in_psram: true
    queue_mode: true
    source_speakers:
      - id: announcement_spk_mixer_input
      - id: media_spk_mixer_input

  # Resampler (stabilità & compatibilità)
  - platform: resampler
    id: media_spk_resampling_input
    output_speaker: media_spk_mixer_input
  - platform: resampler
    id: announcement_spk_resampling_input
    output_speaker: announcement_spk_mixer_input

# -----------------------------
# MEDIA PLAYER
# -----------------------------
media_player:
  - platform: speaker
    id: speaker_media
    name: "${friendly} Speaker"
    volume_increment: 0.1

    media_pipeline:
      speaker: media_spk_resampling_input
      num_channels: 1
      format: MP3
      sample_rate: ${sample_rate_hz}

    announcement_pipeline:
      speaker: announcement_spk_resampling_input
      num_channels: 1
      format: MP3
      sample_rate: ${sample_rate_hz}

    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_spk_mixer_input
          decibel_reduction: ${ducking_db_default}
          duration: ${ducking_apply_s}

    on_play:
      - if:
          condition:
            lambda: 'return id(voice_assistant_phase) == 1;'
          then:
            - logger.log: "Media: PLAY"
            - light.turn_on:
                id: led_ring
                blue: 50%
                red: 0%
                green: 0%
                brightness: 75%
                effect: "Slow Pulse"          
          else:
            - logger.log: "Media: SPEAKING"
            - script.execute: led_speaking

    on_idle:
      - if:
          condition:
            lambda: 'return id(voice_assistant_phase) == 1;'
            - light.turn_off: led_ring
          then:
            - logger.log: "Media: IDLE"
            - script.execute: led_listening

# -----------------------------
# MICRO WAKE WORD
# -----------------------------
micro_wake_word:
  id: mww
  stop_after_detection: false
  microphone:
    microphone: mic_in
    channels: 0
    gain_factor: ${mic_gain_factor}

  models:
    - model: ${wake_word_model}
      id: main_ww

    # Stop word (internal) - enabled only while replying
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: ${stop_word_model_id}
      internal: true

  on_wake_word_detected:
    - lambda: |-
        id(last_wake_word) = wake_word;

    # If wake word is "Stop" -> stop pipeline or announcements
    - if:
        condition:
          lambda: |-
            return (std::string(wake_word) == "Stop");
        then:
          - logger.log: "WakeWord: STOP"
          - voice_assistant.stop:
          - media_player.stop:
              announcement: true
          - switch.turn_off: chat
          - script.execute: led_waiting_wake
        else:
          - if:
              condition:
                switch.is_on: start_voice
              then:
                - logger.log: "WakeWord: MAIN -> start continuous"
                - micro_wake_word.stop:
                - voice_assistant.start_continuous:
                - switch.turn_on: chat
                - script.execute: led_listening
                - lambda: |-
                    id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
                    id(is_tts_active) = false;
                    id(question_flag) = false;
                - script.execute: listening_timeout

# -----------------------------
# VOICE ASSISTANT
# -----------------------------
voice_assistant:
  id: vvoice_assistant
  microphone:
    microphone: mic_in
    channels: 0
    gain_factor: ${mic_gain_factor}

  media_player: speaker_media
  micro_wake_word: mww
  noise_suppression_level: ${va_noise_suppression}
  auto_gain: ${va_auto_gain}
  volume_multiplier: ${va_volume_multiplier}

  on_client_connected:
    - lambda: |-
        id(init_in_progress) = false;
        id(voice_assistant_phase) =
          (id(start_voice).state) ? ${voice_assist_idle_phase_id} : ${voice_assist_muted_phase_id};
    - if:
        condition:
          switch.is_on: start_voice
        then:
          - micro_wake_word.start:
          - script.execute: led_waiting_wake

  on_client_disconnected:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - micro_wake_word.stop:
    - script.execute: led_idle

  on_stt_vad_start:
    - script.stop: listening_timeout

  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: led_thinking

  on_intent_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: led_thinking

  on_tts_start:
    - lambda: |-
        id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
        id(is_tts_active) = true;
    - script.execute: led_speaking

    # Publish last output
    - lambda: |-
        id(last_output).publish_state(x.c_str());

    # Enable stop word only while speaking (optional)
    - if:
        condition:
          lambda: |-
            return std::string("${stop_word_enabled}") == "true";
        then:
          - script.execute: activate_stop_word_once

    # Your "exit" phrase: modalità silenziosa
    - if:
        condition:
          lambda: |-
            std::string t = x;
            for (auto &c : t) c = tolower((unsigned char)c);
            return (t.find("modalità silenziosa") != std::string::npos);
        then:
          - delay: 5s
          - switch.turn_off: chat
          - voice_assistant.stop:
          - script.execute: led_waiting_wake
          - micro_wake_word.start:
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};

  on_stt_end:
    - lambda: |-
        id(last_input).publish_state(x.c_str());

  on_end:
    # Release ducking
    - mixer_speaker.apply_ducking:
        id: media_spk_mixer_input
        decibel_reduction: 0
        duration: ${ducking_release_s}

    - delay: 300ms

    # Continued conversation logic (robusta)
    - if:
        condition:
          and:
            - switch.is_on: chat
            - lambda: 'return id(is_tts_active);'
            - lambda: 'return id(last_wake_word) != "Stop";'
        then:
          # Keep in listening (continuous) -> show listening again
          - lambda: id(voice_assistant_phase) = ${voice_assist_listening_phase_id};
          - script.execute: led_listening
        else:
          # Back to idle waiting for wake word
          - switch.turn_off: chat
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          - script.execute: led_waiting_wake
          - micro_wake_word.start:

    # Reset flags
    - lambda: |-
        id(is_tts_active) = false;
        id(question_flag) = false;

  on_error:
    - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
    - script.execute: led_error
    - delay: 1s
    - if:
        condition:
          switch.is_on: start_voice
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          - micro_wake_word.start:
          - script.execute: led_waiting_wake
        else:
          - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
          - script.execute: led_idle

# -----------------------------
# SWITCHES
# -----------------------------
switch:
  - platform: template
    id: start_voice
    name: "Wake-up Word"
    optimistic: true
    restore_mode: ALWAYS_OFF
    icon: "mdi:microphone-message"
    on_turn_on:
      - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
      - micro_wake_word.start:
      - script.execute: led_waiting_wake
    on_turn_off:
      - voice_assistant.stop:
      - micro_wake_word.stop:
      - switch.turn_off: chat
      - lambda: id(voice_assistant_phase) = ${voice_assist_muted_phase_id};
      - script.execute: led_idle

  - platform: template
    id: chat
    name: "${ActivateChat}"
    optimistic: true
    restore_mode: ALWAYS_OFF
    icon: "mdi:chat"
    on_turn_on:
      - logger.log: "Chat: ON"
    on_turn_off:
      - logger.log: "Chat: OFF"

# -----------------------------
# BUTTONS
# -----------------------------
button:
  - platform: safe_mode
    name: "Safe Mode"
    entity_category: diagnostic

  - platform: restart
    name: "Restart"
    entity_category: diagnostic

  - platform: factory_reset
    name: "Factory Reset"
    entity_category: diagnostic

# -----------------------------
# TEXT SENSORS (debug)
# -----------------------------
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP"
      entity_category: diagnostic
    bssid:
      name: "BSSID"
      entity_category: diagnostic

  - platform: version
    name: "ESPHome Version"
    entity_category: diagnostic

  - platform: template
    id: last_input
    name: "Utente"

  - platform: template
    id: last_output
    name: "Elsa"

# -----------------------------
# WAKE WORD SENSITIVITY (select)
# -----------------------------
select:
  - platform: template
    name: "Wake word sensitivity"
    optimistic: true
    initial_option: "Sensibilità normale"
    restore_value: true
    entity_category: config
    options:
      - "Sensibilità minima"
      - "Sensibilità bassa"
      - "Sensibilità normale"
      - "Sensibilità alta"
    on_value:
      lambda: |-
        if (x == "Slightly sensitive") {
          id(main_ww).set_probability_cutoff(${ww_cutoff_slight});
        } else if (x == "Slightly+ sensitive") {
          id(main_ww).set_probability_cutoff(${ww_cutoff_slightp});
        } else if (x == "Moderately sensitive") {
          id(main_ww).set_probability_cutoff(${ww_cutoff_mod});
        } else if (x == "Very sensitive") {
          id(main_ww).set_probability_cutoff(${ww_cutoff_very});
        }

# -----------------------------
# SCRIPTS (timeout + stop word)
# -----------------------------
script:
  - id: listening_timeout
    mode: restart
    then:
      - delay: ${listening_timeout_s}
      - if:
          condition:
            lambda: |-
              return id(voice_assistant_phase) == ${voice_assist_listening_phase_id};
          then:
            - logger.log: "Listening timeout -> stop VA"
            - voice_assistant.stop:
            - switch.turn_off: chat
            - script.execute: led_waiting_wake
            - micro_wake_word.start:
            - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};

  - id: activate_stop_word_once
    mode: restart
    then:
      - delay: 1s
      - micro_wake_word.enable_model: ${stop_word_model_id}
      - wait_until:
          not:
            media_player.is_announcing:
        timeout: 20s
      - micro_wake_word.disable_model: ${stop_word_model_id}

  # LED state scripts
  - id: led_idle
    then:
      - light.turn_off: led_ring

  - id: led_waiting_wake
    then:
      - light.turn_on:
          id: led_ring
          effect: "VA Standby"
      - lambda: |-
          id(fg_r)=${standby_r1}; id(fg_g)=${standby_g1}; id(fg_b)=${standby_b1};
          id(bg_r)=0; id(bg_g)=0; id(bg_b)=0;

  - id: led_listening
    then:
      - light.turn_on:
          id: led_ring
          effect: "VA Rotate"
      - lambda: |-
          id(fg_r)=${listen_fg_r}; id(fg_g)=${listen_fg_g}; id(fg_b)=${listen_fg_b};
          id(bg_r)=${listen_bg_r}; id(bg_g)=${listen_bg_g}; id(bg_b)=${listen_bg_b};

  - id: led_thinking
    then:
      - light.turn_on:
          id: led_ring
          effect: "VA Rotate"
      - lambda: |-
          id(fg_r)=${think_fg_r}; id(fg_g)=${think_fg_g}; id(fg_b)=${think_fg_b};
          id(bg_r)=${think_bg_r}; id(bg_g)=${think_bg_g}; id(bg_b)=${think_bg_b};

  - id: led_speaking
    then:
      - light.turn_on:
          id: led_ring
          effect: "VA Rotate"
      - lambda: |-
          id(fg_r)=${speak_fg_r}; id(fg_g)=${speak_fg_g}; id(fg_b)=${speak_fg_b};
          id(bg_r)=${speak_bg_r}; id(bg_g)=${speak_bg_g}; id(bg_b)=${speak_bg_b};

  - id: led_error
    then:
      - light.turn_on:
          id: led_ring
          effect: "VA Rotate"
      - lambda: |-
          id(fg_r)=${err_fg_r}; id(fg_g)=${err_fg_g}; id(fg_b)=${err_fg_b};
          id(bg_r)=${err_bg_r}; id(bg_g)=${err_bg_g}; id(bg_b)=${err_bg_b};

# -----------------------------
# LED RING
# -----------------------------
light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    rgb_order: GRB
    id: led_ring
    name: "LED Ring"
    pin: ${led_pin}
    num_leds: ${led_count}
    restore_mode: ALWAYS_OFF
    default_transition_length: 0s
    effects:
      - addressable_scan:
          name: "Scanning"
          move_interval: 150ms
          scan_width: 2
      - pulse:
          name: "Slow Pulse"
          transition_length: 770ms
          update_interval: 770ms
          min_brightness: 10%
          max_brightness: 20%

      - addressable_lambda:
          name: "VA Rotate"
          update_interval: ${led_rotate_ms}
          lambda: |-
            static int pos = 0;
            const int N = it.size();
            for (int i = 0; i < N; i++) it[i] = Color(id(bg_r), id(bg_g), id(bg_b));
            it[pos % N] = Color(id(fg_r), id(fg_g), id(fg_b));
            pos = (pos + 1) % N;
      - addressable_lambda:
          name: "VA Standby"
          update_interval: ${led_standby_ms}
          lambda: |-
            const int N = it.size();
            const uint32_t now = millis();
            for (int i = 0; i < N; i++) it[i] = Color(0,0,0);
            int pos1 = (now / ${standby_speed_ms}) % N;
            int pos2 = (pos1 + ${standby_gap}) % N;
            it[pos1] = Color(${standby_r1}, ${standby_g1}, ${standby_b1});
            it[pos2] = Color(${standby_r2}, ${standby_g2}, ${standby_b2});
